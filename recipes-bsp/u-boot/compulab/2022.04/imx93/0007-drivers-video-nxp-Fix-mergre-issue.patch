From 02ffa775f81ba5c200cf31529da5ae39938ac122 Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Fri, 7 Apr 2023 10:41:50 +0300
Subject: [PATCH] drivers: video: nxp: Fix mergre issue

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 drivers/video/nxp/imx/Kconfig               |   28 +-
 drivers/video/nxp/imx/Makefile              |    4 +-
 drivers/video/nxp/imx/dw/Kconfig            |   33 -
 drivers/video/nxp/imx/dw/Makefile           |    4 -
 drivers/video/nxp/imx/dw/dw-hdmi-audio.h    |   23 -
 drivers/video/nxp/imx/dw/dw-hdmi-cec.h      |   19 -
 drivers/video/nxp/imx/dw/dw-hdmi-detect.c   |   74 -
 drivers/video/nxp/imx/dw/dw-hdmi-i2c.c      |  415 ----
 drivers/video/nxp/imx/dw/dw-hdmi.c          | 2020 -------------------
 drivers/video/nxp/imx/dw/dw-hdmi.h          | 1128 -----------
 drivers/video/nxp/imx/dw/dw_hdmi-imx.c      |  421 ----
 drivers/video/nxp/imx/dw/dw_hdmi.h          |  225 ---
 drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.c |  236 ---
 drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.h |   27 -
 drivers/video/nxp/imx/imx8mp_lvds.c         |  281 ---
 drivers/video/nxp/imx/imx_lcdifv3.c         |  230 +--
 drivers/video/nxp/imx/videomodes.h          |  105 -
 17 files changed, 49 insertions(+), 5224 deletions(-)
 delete mode 100644 drivers/video/nxp/imx/dw/Kconfig
 delete mode 100644 drivers/video/nxp/imx/dw/Makefile
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi-audio.h
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi-cec.h
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi-detect.c
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi-i2c.c
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi.c
 delete mode 100644 drivers/video/nxp/imx/dw/dw-hdmi.h
 delete mode 100644 drivers/video/nxp/imx/dw/dw_hdmi-imx.c
 delete mode 100644 drivers/video/nxp/imx/dw/dw_hdmi.h
 delete mode 100644 drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.c
 delete mode 100644 drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.h
 delete mode 100644 drivers/video/nxp/imx/imx8mp_lvds.c
 delete mode 100644 drivers/video/nxp/imx/videomodes.h

diff --git a/drivers/video/nxp/imx/Kconfig b/drivers/video/nxp/imx/Kconfig
index 7acbea1f3b..1824b969fb 100644
--- a/drivers/video/nxp/imx/Kconfig
+++ b/drivers/video/nxp/imx/Kconfig
@@ -34,15 +34,6 @@ config VIDEO_IMX8_LVDS
 	help
 	  Support for i.MX8 LDVS bridge controller for i.MX8 processors.
 
-config VIDEO_IMX8MP_LVDS
-	bool "i.MX8MP LDVS bridge support"
-	default n
-	depends on IMX8MP && DM_VIDEO
-	select DISPLAY
-	select VIDEO_LINK
-	help
-	  Support for i.MX8MP LDVS bridge controller for i.MX8 processors.
-
 config VIDEO_IMX_HDP_LOAD
 	bool "i.MX8 HDMI/DP firmware loading"
 	default n
@@ -109,9 +100,18 @@ config VIDEO_IMX_NW_DSI
 	  This option enables support DSI internal bridge which can be used on
 	  devices which have DSI devices connected.
 
+config VIDEO_IMX_DW_DSI
+	bool "Enable Synopsys DW DSI video support"
+	select VIDEO_BRIDGE
+	select VIDEO_DW_MIPI_DSI
+	select VIDEO_LINK
+	help
+	  This option enables support DSI internal bridge which can be used on
+	  devices which have DSI devices connected.
+
 config VIDEO_IMX_LCDIFV3
 	bool "i.MX LCDIFv3 support"
-	depends on DM_VIDEO && IMX8MP
+	depends on DM_VIDEO && (IMX8MP || ARCH_IMX9)
 	select VIDEO_LINK
 	help
 	  Support for i.MX8MP LCDIFv3 controller.
@@ -123,4 +123,10 @@ config VIDEO_IMX_DCNANO
 	help
 	  Support for i.MX8ULP DCNANO LCD controller.
 
-source "drivers/video/nxp/imx/dw/Kconfig"
+config VIDEO_IMX93_PARALLEL_DISPLAY_FORMAT
+	bool "Support for i.MX93 parallel display format"
+	select VIDEO_BRIDGE
+	select VIDEO_LINK
+	help
+	  Choose this to enable the internal parallel display format
+	  configuration found on i.MX93 processors.
diff --git a/drivers/video/nxp/imx/Makefile b/drivers/video/nxp/imx/Makefile
index d77b86307e..019789fe0c 100644
--- a/drivers/video/nxp/imx/Makefile
+++ b/drivers/video/nxp/imx/Makefile
@@ -11,9 +11,9 @@ obj-$(CONFIG_VIDEO_IMX8M_DCSS) += imx8m_dcss.o
 obj-$(CONFIG_VIDEO_SEC_MIPI_DSI) += sec_mipi_dsim.o
 obj-$(CONFIG_VIDEO_IMX_SEC_DSI) += sec_dsim_imx.o
 obj-$(CONFIG_VIDEO_IMX_LCDIFV3) += imx_lcdifv3.o
-obj-$(CONFIG_VIDEO_IMX8MP_LVDS) += imx8mp_lvds.o
 obj-$(CONFIG_VIDEO_NW_MIPI_DSI) += mipi_dsi_northwest.o
 obj-$(CONFIG_VIDEO_IMX_NW_DSI) += nw_dsi_imx.o
+obj-$(CONFIG_VIDEO_IMX_DW_DSI) += dw_dsi_imx.o
 obj-$(CONFIG_VIDEO_IMX_DCNANO) += dcnano.o
+obj-$(CONFIG_VIDEO_IMX93_PARALLEL_DISPLAY_FORMAT) += imx93-parallel-disp-fmt.o
 obj-y += hdmi/
-obj-y += dw/
diff --git a/drivers/video/nxp/imx/dw/Kconfig b/drivers/video/nxp/imx/dw/Kconfig
deleted file mode 100644
index 7df1ac23e6..0000000000
--- a/drivers/video/nxp/imx/dw/Kconfig
+++ /dev/null
@@ -1,33 +0,0 @@
-config VIDEO_DW_HDMI
-	bool "DW HDMI library"
-
-config VIDEO_DW_HDMI_I2C
-	bool "DW HDMI i2c ddc device"
-
-config IMX8MP_HDMI_PAVI
-	bool
-
-config DRM_SCDC_HELPER
-	bool "Enable scdc helper library"
-
-config IMX8M_PM_DOMAINS
-	bool "Enable i.MX8M pm domains driver"
-	depends on POWER_DOMAIN && ARCH_IMX8M
-	help
-	  Enable support for manipulating NXP i.MX8MM/MN/MP on-SoC power domains via
-	  requests to the ATF.
-
-config VIDEO_IMX8MP_HDMI
-	bool "i.MX8MP HDMI support"
-	default n
-	depends on DM_VIDEO && IMX8MP
-	select DRM_SCDC_HELPER
-	select VIDEO_DW_HDMI
-	select VIDEO_DW_HDMI_I2C
-	select PHY_SAMSUNG_HDMI
-	select IMX8MP_HDMI_PAVI
-	select RESET_IMX_HDMIMIX
-	select DISPLAY
-	select DISPLAY_DETECT
-	help
-	  Support for i.MX8MP HDMI controller.
diff --git a/drivers/video/nxp/imx/dw/Makefile b/drivers/video/nxp/imx/dw/Makefile
deleted file mode 100644
index eaae526b7a..0000000000
--- a/drivers/video/nxp/imx/dw/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-obj-$(CONFIG_VIDEO_IMX8MP_HDMI) += dw_hdmi-imx.o dw-hdmi-detect.o
-obj-$(CONFIG_IMX8MP_HDMI_PAVI) += imx8mp-hdmi-pavi.o
-obj-$(CONFIG_VIDEO_DW_HDMI_I2C) += dw-hdmi-i2c.o
-obj-$(CONFIG_VIDEO_DW_HDMI) += dw-hdmi.o
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi-audio.h b/drivers/video/nxp/imx/dw/dw-hdmi-audio.h
deleted file mode 100644
index cb07dc0da5..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi-audio.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef DW_HDMI_AUDIO_H
-#define DW_HDMI_AUDIO_H
-
-struct dw_hdmi;
-
-struct dw_hdmi_audio_data {
-	phys_addr_t phys;
-	void __iomem *base;
-	int irq;
-	struct dw_hdmi *hdmi;
-	u8 *eld;
-};
-
-struct dw_hdmi_i2s_audio_data {
-	struct dw_hdmi *hdmi;
-	u8 *eld;
-
-	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
-	u8 (*read)(struct dw_hdmi *hdmi, int offset);
-};
-
-#endif
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi-cec.h b/drivers/video/nxp/imx/dw/dw-hdmi-cec.h
deleted file mode 100644
index cf4dc121a2..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi-cec.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#ifndef DW_HDMI_CEC_H
-#define DW_HDMI_CEC_H
-
-struct dw_hdmi;
-
-struct dw_hdmi_cec_ops {
-	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
-	u8 (*read)(struct dw_hdmi *hdmi, int offset);
-	void (*enable)(struct dw_hdmi *hdmi);
-	void (*disable)(struct dw_hdmi *hdmi);
-};
-
-struct dw_hdmi_cec_data {
-	struct dw_hdmi *hdmi;
-	const struct dw_hdmi_cec_ops *ops;
-	int irq;
-};
-
-#endif
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi-detect.c b/drivers/video/nxp/imx/dw/dw-hdmi-detect.c
deleted file mode 100644
index ff30f57c27..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi-detect.c
+++ /dev/null
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DesignWare HDMI hpd driver
- *
- * Copyright (C) 2021 Boundary Devices.
- */
-
-#include <common.h>
-#include <clk.h>
-#include <display_detect.h>
-#include <dm/device.h>
-#include <dm/ofnode.h>
-#include <dm/read.h>
-#include <regmap.h>
-
-#define HDMI_PHY_STAT0	0x0004
-#define HDMI_PHY_HPD	0x02
-
-struct dw_hdmi_detect {
-	struct regmap *regm;
-};
-
-static int dw_hdmi_detect_probe(struct udevice *dev)
-{
-	struct dw_hdmi_detect *dhd = dev_get_priv(dev);
-	ofnode np = dev_ofnode(dev);
-	struct regmap *regm;
-	int ret;
-
-	ret = regmap_init_mem(np, &regm);
-	if (ret) {
-		debug("%s: Couldn't create regmap %d\n", __func__, ret);
-		return ret;
-	}
-	dhd->regm = regm;
-
-	return ret;
-}
-
-static int dw_hdmi_detect_remove(struct udevice *dev)
-{
-	return 0;
-}
-
-static bool dw_hdmi_detect_hpd(struct udevice *dev)
-{
-	struct dw_hdmi_detect *dhd = dev_get_priv(dev);
-	unsigned int stat = 0;
-
-	regmap_raw_read(dhd->regm, HDMI_PHY_STAT0, &stat, REGMAP_SIZE_8);
-
-	return stat & HDMI_PHY_HPD ? 1 : 0;
-}
-
-struct dm_display_detect_ops dw_hdmi_detect_ops = {
-	.detect = dw_hdmi_detect_hpd,
-};
-
-static const struct udevice_id dw_hdmi_detect_dt_ids[] = {
-	{ .compatible = "fsl,imx6q-hdmi-hpd",},
-	{ .compatible = "fsl,imx8mp-hdmi-hpd",},
-	{},
-};
-
-U_BOOT_DRIVER(dw_hdmi_hpd) = {
-	.name				= "dw-hdmi-hdp",
-	.id				= UCLASS_DISPLAY_DETECT,
-	.of_match			= dw_hdmi_detect_dt_ids,
-	.bind				= dm_scan_fdt_dev,
-	.probe				= dw_hdmi_detect_probe,
-	.remove				= dw_hdmi_detect_remove,
-	.ops				= &dw_hdmi_detect_ops,
-	.priv_auto			= sizeof(struct dw_hdmi_detect),
-};
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi-i2c.c b/drivers/video/nxp/imx/dw/dw-hdmi-i2c.c
deleted file mode 100644
index 165920ba5f..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi-i2c.c
+++ /dev/null
@@ -1,415 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DesignWare High-Definition Multimedia Interface (HDMI) driver
- *
- * Copyright (C) 2021 Boundary Devices Inc.
- * Copyright (C) 2013-2015 Mentor Graphics Inc.
- * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
- * Copyright (C) 2010, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
- */
-
-#include <common.h>
-#include <log.h>
-#include <asm/arch/clock.h>
-#include <asm/arch/imx-regs.h>
-#include <asm/mach-imx/mxc_i2c.h>
-#include <asm/mach-imx/sys_proto.h>
-#include <asm/io.h>
-#include <dm.h>
-#include <dm/device_compat.h>
-#include <dm/pinctrl.h>
-#include <fdtdec.h>
-#include <i2c.h>
-#include <linux/delay.h>
-#include <linux/errno.h>
-#include <regmap.h>
-#include <watchdog.h>
-#include "dw-hdmi.h"
-
-#define DDC_CI_ADDR		0x37
-#define DDC_SEGMENT_ADDR	0x30
-
-struct dw_hdmi_i2c {
-	struct udevice *bus;
-	struct regmap *regm;
-	/* Use gpio to force bus idle when bus state is abnormal */
-	struct gpio_desc scl_gpio;
-	struct gpio_desc sda_gpio;
-	unsigned int reg_shift;
-	u32 speed;
-	u8 stat;
-	struct clk *bulk_clks;
-
-	u8 slave_reg;
-	bool is_regaddr;
-	bool is_segment;
-};
-
-static inline void hdmi_writeb(struct dw_hdmi_i2c *i2c, u8 val, int offset)
-{
-	regmap_raw_write(i2c->regm, offset << i2c->reg_shift, &val, REGMAP_SIZE_8);
-}
-
-static inline u8 hdmi_readb(struct dw_hdmi_i2c *i2c, int offset)
-{
-	unsigned int val = 0;
-
-	regmap_raw_read(i2c->regm, offset << i2c->reg_shift, &val, REGMAP_SIZE_8);
-
-	return val;
-}
-
-static void dw_hdmi_i2c_init(struct dw_hdmi_i2c *i2c)
-{
-	hdmi_writeb(i2c, HDMI_PHY_I2CM_INT_ADDR_DONE_POL,
-		    HDMI_PHY_I2CM_INT_ADDR);
-
-	hdmi_writeb(i2c, HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL |
-		    HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL,
-		    HDMI_PHY_I2CM_CTLINT_ADDR);
-
-	/* Software reset */
-	hdmi_writeb(i2c, 0x00, HDMI_I2CM_SOFTRSTZ);
-
-	/* Set Standard Mode speed (determined to be 100KHz on iMX6) */
-	hdmi_writeb(i2c, 0x00, HDMI_I2CM_DIV);
-
-	/* Set done, not acknowledged and arbitration interrupt polarities */
-	hdmi_writeb(i2c, HDMI_I2CM_INT_DONE_POL, HDMI_I2CM_INT);
-	hdmi_writeb(i2c, HDMI_I2CM_CTLINT_NAC_POL | HDMI_I2CM_CTLINT_ARB_POL,
-		    HDMI_I2CM_CTLINT);
-
-	/* Clear DONE and ERROR interrupts */
-	hdmi_writeb(i2c, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_I2CM_STAT0);
-
-	/* Mute DONE and ERROR interrupts */
-	hdmi_writeb(i2c, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_MUTE_I2CM_STAT0);
-}
-
-static bool dw_hdmi_i2c_unwedge(struct dw_hdmi_i2c *i2c)
-{
-	/* If no unwedge state then give up */
-	printf("Attempting to unwedge stuck i2c bus\n");
-
-	/*
-	 * This is a huge hack to workaround a problem where the dw_hdmi i2c
-	 * bus could sometimes get wedged.  Once wedged there doesn't appear
-	 * to be any way to unwedge it (including the HDMI_I2CM_SOFTRSTZ)
-	 * other than pulsing the SDA line.
-	 *
-	 * We appear to be able to pulse the SDA line (in the eyes of dw_hdmi)
-	 * by:
-	 * 1. Remux the pin as a GPIO output, driven low.
-	 * 2. Wait a little while.  1 ms seems to work, but we'll do 10.
-	 * 3. Immediately jump to remux the pin as dw_hdmi i2c again.
-	 *
-	 * At the moment of remuxing, the line will still be low due to its
-	 * recent stint as an output, but then it will be pulled high by the
-	 * (presumed) external pullup.  dw_hdmi seems to see this as a rising
-	 * edge and that seems to get it out of its jam.
-	 *
-	 * This wedging was only ever seen on one TV, and only on one of
-	 * its HDMI ports.  It happened when the TV was powered on while the
-	 * device was plugged in.  A scope trace shows the TV bringing both SDA
-	 * and SCL low, then bringing them both back up at roughly the same
-	 * time.  Presumably this confuses dw_hdmi because it saw activity but
-	 * no real STOP (maybe it thinks there's another master on the bus?).
-	 * Giving it a clean rising edge of SDA while SCL is already high
-	 * presumably makes dw_hdmi see a STOP which seems to bring dw_hdmi out
-	 * of its stupor.
-	 *
-	 * Note that after coming back alive, transfers seem to immediately
-	 * resume, so if we unwedge due to a timeout we should wait a little
-	 * longer for our transfer to finish, since it might have just started
-	 * now.
-	 */
-	pinctrl_select_state(i2c->bus, "unwedge");
-	mdelay(10);
-	pinctrl_select_state(i2c->bus, "default");
-
-	return true;
-}
-
-static int dw_hdmi_i2c_poll(struct dw_hdmi_i2c *i2c)
-{
-	unsigned int stat;
-
-	stat = hdmi_readb(i2c, HDMI_IH_I2CM_STAT0);
-	if (!stat)
-		return 0;
-
-	hdmi_writeb(i2c, stat, HDMI_IH_I2CM_STAT0);
-	i2c->stat = stat;
-	return 1;
-}
-
-static int i2c_wait(struct dw_hdmi_i2c *i2c, int jiffies)
-{
-	ulong start_time = get_timer(0);
-	ulong elapsed;
-
-	do {
-		elapsed = get_timer(start_time);
-		if (dw_hdmi_i2c_poll(i2c))
-			break;
-		if (elapsed > jiffies)
-			return -ETIMEDOUT;
-		udelay(100);
-	} while (1);
-	return 0;
-}
-
-static int dw_hdmi_i2c_wait(struct dw_hdmi_i2c *i2c)
-{
-	int stat;
-
-	stat = i2c_wait(i2c, CONFIG_SYS_HZ / 10);
-	if (stat < 0) {
-		/* If we can't unwedge, return timeout */
-		if (!dw_hdmi_i2c_unwedge(i2c))
-			return -EAGAIN;
-
-		/* We tried to unwedge; give it another chance */
-		stat = i2c_wait(i2c, CONFIG_SYS_HZ / 10);
-		if (stat < 0)
-			return -EAGAIN;
-	}
-
-	/* Check for error condition on the bus */
-	if (i2c->stat & HDMI_IH_I2CM_STAT0_ERROR)
-		return -EIO;
-
-	return 0;
-}
-
-static int dw_hdmi_i2c_read(struct dw_hdmi_i2c *i2c,
-			    unsigned char *buf, unsigned int length)
-{
-	int ret;
-
-	if (!i2c->is_regaddr) {
-		printf("set read register address to 0\n");
-		i2c->slave_reg = 0x00;
-		i2c->is_regaddr = true;
-	}
-
-	while (length--) {
-		hdmi_writeb(i2c, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
-		if (i2c->is_segment)
-			hdmi_writeb(i2c, HDMI_I2CM_OPERATION_READ_EXT,
-				    HDMI_I2CM_OPERATION);
-		else
-			hdmi_writeb(i2c, HDMI_I2CM_OPERATION_READ,
-				    HDMI_I2CM_OPERATION);
-
-		ret = dw_hdmi_i2c_wait(i2c);
-		if (ret)
-			return ret;
-
-		*buf++ = hdmi_readb(i2c, HDMI_I2CM_DATAI);
-	}
-	i2c->is_segment = false;
-
-	return 0;
-}
-
-static int dw_hdmi_i2c_write(struct dw_hdmi_i2c *i2c,
-			     unsigned char *buf, unsigned int length)
-{
-	int ret;
-
-	if (!i2c->is_regaddr) {
-		/* Use the first write byte as register address */
-		i2c->slave_reg = buf[0];
-		length--;
-		buf++;
-		i2c->is_regaddr = true;
-	}
-
-	while (length--) {
-		hdmi_writeb(i2c, *buf++, HDMI_I2CM_DATAO);
-		hdmi_writeb(i2c, i2c->slave_reg++, HDMI_I2CM_ADDRESS);
-		hdmi_writeb(i2c, HDMI_I2CM_OPERATION_WRITE,
-			    HDMI_I2CM_OPERATION);
-
-		ret = dw_hdmi_i2c_wait(i2c);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static int dw_hdmi_i2c_xfer(struct udevice *bus, struct i2c_msg *msgs, int num)
-{
-	struct dw_hdmi_i2c *i2c = dev_get_priv(bus);
-	u8 addr = msgs[0].addr;
-	int i, ret = 0;
-
-	if (addr == DDC_CI_ADDR)
-		/*
-		 * The internal I2C controller does not support the multi-byte
-		 * read and write operations needed for DDC/CI.
-		 * TOFIX: Blacklist the DDC/CI address until we filter out
-		 * unsupported I2C operations.
-		 */
-		return -EOPNOTSUPP;
-
-	printf("xfer: num: %d, addr: %#x\n", num, addr);
-
-	for (i = 0; i < num; i++) {
-		if (msgs[i].len == 0) {
-			printf("unsupported transfer %d/%d, no data\n",
-				i + 1, num);
-			return -EOPNOTSUPP;
-		}
-	}
-
-	mutex_lock(&i2c->lock);
-
-	/* Unmute DONE and ERROR interrupts */
-	hdmi_writeb(i2c, 0x00, HDMI_IH_MUTE_I2CM_STAT0);
-
-	/* Set slave device address taken from the first I2C message */
-	hdmi_writeb(i2c, addr, HDMI_I2CM_SLAVE);
-
-	/* Set slave device register address on transfer */
-	i2c->is_regaddr = false;
-
-	/* Set segment pointer for I2C extended read mode operation */
-	i2c->is_segment = false;
-
-	for (i = 0; i < num; i++) {
-		printf("xfer: num: %d/%d, len: %d, flags: %#x\n",
-			i + 1, num, msgs[i].len, msgs[i].flags);
-		if (msgs[i].addr == DDC_SEGMENT_ADDR && msgs[i].len == 1 &&
-				!(msgs[i].flags & I2C_M_RD)) {
-			i2c->is_segment = true;
-			hdmi_writeb(i2c, DDC_SEGMENT_ADDR, HDMI_I2CM_SEGADDR);
-			hdmi_writeb(i2c, *msgs[i].buf, HDMI_I2CM_SEGPTR);
-		} if (msgs[i].addr == 0x59 && msgs[i].len == 1 &&
-					(msgs[i].flags & I2C_M_RD)) {
-			/* Sceptre monitor locks up edid if this is read */
-			ret = -EIO;
-		} else {
-			if (msgs[i].flags & I2C_M_RD)
-				ret = dw_hdmi_i2c_read(i2c, msgs[i].buf,
-						       msgs[i].len);
-			else
-				ret = dw_hdmi_i2c_write(i2c, msgs[i].buf,
-							msgs[i].len);
-		}
-		if (ret < 0)
-			break;
-	}
-
-	if (!ret)
-		ret = num;
-
-	/* Mute DONE and ERROR interrupts */
-	hdmi_writeb(i2c, HDMI_IH_I2CM_STAT0_ERROR | HDMI_IH_I2CM_STAT0_DONE,
-		    HDMI_IH_MUTE_I2CM_STAT0);
-
-	mutex_unlock(&i2c->lock);
-
-	return ret;
-}
-
-static int dw_hdmi_i2c_set_bus_speed(struct udevice *bus, uint speed)
-{
-	struct dw_hdmi_i2c *i2c = dev_get_priv(bus);
-
-	i2c->speed = speed;
-	return 0;
-}
-
-static int dw_hdmi_i2c_probe_chip(struct udevice *bus, u32 chip_addr,
-			      u32 chip_flags)
-{
-	struct i2c_msg msg;
-	unsigned char buffer[4];
-	int ret;
-
-	msg.addr = chip_addr;
-	msg.flags = I2C_M_RD;
-	msg.len = 1;
-	msg.buf = buffer;
-	ret = dw_hdmi_i2c_xfer(bus, &msg, 1);
-	if (ret < 0)
-		return ret;
-	if (ret != 1)
-		return -EIO;
-	return 0;
-}
-
-#if 0
-static const char* const clock_names[] = {
-	"iahb",    "isfr",    "phy_int", "prep_clk",
-	"skp_clk", "sfr_clk", "pix_clk", "cec_clk",
-	"apb_clk", "hpi_clk", "fdcc_ref", "pipe_clk"
-};
-#endif
-
-static int dw_hdmi_i2c_probe(struct udevice *bus)
-{
-	struct dw_hdmi_i2c *i2c = dev_get_priv(bus);
-	int ret;
-#if 0
-	int i;
-#endif
-
-	i2c->bus = bus;
-	ret = regmap_init_mem(dev_ofnode(bus), &i2c->regm);
-	if (ret) {
-		printf("%s: Couldn't create regmap\n", __func__);
-		return ret;
-	}
-
-#if 0
-	ret = devm_clk_get_enable_bulk(bus, clock_names, ARRAY_SIZE(clock_names),
-			4, &i2c->bulk_clks);
-	if (ret)
-		goto clks_disable;
-#endif
-	/*
-	 * Reset HDMI DDC I2C master controller and mute I2CM interrupts.
-	 * Even if we are using a separate i2c adapter doing this doesn't
-	 * hurt.
-	 */
-	dw_hdmi_i2c_init(i2c);
-	return 0;
-#if 0
-clks_disable:
-	if (i2c->bulk_clks) {
-		for (i = ARRAY_SIZE(clock_names) - 1; i >= 0; i--) {
-			if (i2c->bulk_clks[i].dev)
-				clk_disable_unprepare(&i2c->bulk_clks[i]);
-		}
-	}
-	return ret;
-#endif
-}
-
-static const struct dm_i2c_ops dw_hdmi_i2c_ops = {
-	.xfer		= dw_hdmi_i2c_xfer,
-	.probe_chip	= dw_hdmi_i2c_probe_chip,
-	.set_bus_speed	= dw_hdmi_i2c_set_bus_speed,
-};
-
-static const struct udevice_id dw_hdmi_i2c_dt_ids[] = {
-	{ .compatible = "fsl,imx6q-hdmi-i2c",},
-	{ .compatible = "fsl,imx6dl-hdmi-i2c",},
-	{ .compatible = "fsl,imx8mp-hdmi-i2c",},
-	{},
-};
-
-U_BOOT_DRIVER(dw_hdmi_i2c) = {
-	.name = "dw_hdmi_i2c",
-	.id = UCLASS_I2C,
-	.of_match = dw_hdmi_i2c_dt_ids,
-	.probe = dw_hdmi_i2c_probe,
-	.priv_auto = sizeof(struct dw_hdmi_i2c),
-	.ops = &dw_hdmi_i2c_ops,
-};
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi.c b/drivers/video/nxp/imx/dw/dw-hdmi.c
deleted file mode 100644
index 0d1a2db32f..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi.c
+++ /dev/null
@@ -1,2020 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * DesignWare High-Definition Multimedia Interface (HDMI) driver
- *
- * Copyright (C) 2013-2015 Mentor Graphics Inc.
- * Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
- * Copyright (C) 2010, Guennadi Liakhovetski <g.liakhovetski@gmx.de>
- */
-
-#include <common.h>
-#include <backlight.h>
-#include <clk.h>
-#include <display.h>
-#include <div64.h>
-#include <dm/device.h>
-#include <dm/read.h>
-#include <dm/device_compat.h>
-#include <drm_scdc_helper.h>
-#include <fdtdec.h>
-#include <generic-phy.h>
-#include <i2c.h>
-#include <linux/hdmi.h>
-#include <media_bus_format.h>
-#include <panel.h>
-#include <regmap.h>
-#include <reset.h>
-#include <syscon.h>
-#include "dw-hdmi-audio.h"
-#include "dw-hdmi-cec.h"
-#include "dw-hdmi.h"
-#include "dw_hdmi.h"
-
-
-#define HDMI_EDID_LEN		512
-
-/* DW-HDMI Controller >= 0x200a are at least compliant with SCDC version 1 */
-#define SCDC_MIN_SOURCE_VERSION	0x1
-
-#define HDMI14_MAX_TMDSCLK	340000000
-
-enum hdmi_datamap {
-	RGB444_8B = 0x01,
-	RGB444_10B = 0x03,
-	RGB444_12B = 0x05,
-	RGB444_16B = 0x07,
-	YCbCr444_8B = 0x09,
-	YCbCr444_10B = 0x0B,
-	YCbCr444_12B = 0x0D,
-	YCbCr444_16B = 0x0F,
-	YCbCr422_8B = 0x16,
-	YCbCr422_10B = 0x14,
-	YCbCr422_12B = 0x12,
-};
-
-static const u16 csc_coeff_default[3][4] = {
-	{ 0x2000, 0x0000, 0x0000, 0x0000 },
-	{ 0x0000, 0x2000, 0x0000, 0x0000 },
-	{ 0x0000, 0x0000, 0x2000, 0x0000 }
-};
-
-static const u16 csc_coeff_rgb_out_eitu601[3][4] = {
-	{ 0x2000, 0x6926, 0x74fd, 0x010e },
-	{ 0x2000, 0x2cdd, 0x0000, 0x7e9a },
-	{ 0x2000, 0x0000, 0x38b4, 0x7e3b }
-};
-
-static const u16 csc_coeff_rgb_out_eitu709[3][4] = {
-	{ 0x2000, 0x7106, 0x7a02, 0x00a7 },
-	{ 0x2000, 0x3264, 0x0000, 0x7e6d },
-	{ 0x2000, 0x0000, 0x3b61, 0x7e25 }
-};
-
-static const u16 csc_coeff_rgb_in_eitu601[3][4] = {
-	{ 0x2591, 0x1322, 0x074b, 0x0000 },
-	{ 0x6535, 0x2000, 0x7acc, 0x0200 },
-	{ 0x6acd, 0x7534, 0x2000, 0x0200 }
-};
-
-static const u16 csc_coeff_rgb_in_eitu709[3][4] = {
-	{ 0x2dc5, 0x0d9b, 0x049e, 0x0000 },
-	{ 0x62f0, 0x2000, 0x7d11, 0x0200 },
-	{ 0x6756, 0x78ab, 0x2000, 0x0200 }
-};
-
-struct hdmi_vmode {
-	bool mdataenablepolarity;
-
-	unsigned int mpixelclock;
-	unsigned int mpixelrepetitioninput;
-	unsigned int mpixelrepetitionoutput;
-	unsigned int mtmdsclock;
-};
-
-struct hdmi_data_info {
-	unsigned int enc_in_bus_format;
-	unsigned int enc_out_bus_format;
-	unsigned int enc_in_encoding;
-	unsigned int enc_out_encoding;
-	unsigned int pix_repet_factor;
-	unsigned int hdcp_enable;
-	struct hdmi_vmode video_mode;
-};
-
-struct dw_hdmi_phy_data {
-	enum dw_hdmi_phy_type type;
-	const char *name;
-	unsigned int gen;
-	bool has_svsret;
-	int (*configure)(struct dw_hdmi *hdmi,
-			 const struct dw_hdmi_plat_data *pdata,
-			 unsigned long mpixelclock);
-};
-
-struct scdc {
-	bool supported;
-	bool scrambling_supported;
-	bool scrambling_low_rates;
-};
-
-struct dw_hdmi {
-	unsigned int version;
-
-	struct platform_device *audio;
-	struct platform_device *cec;
-	struct udevice *dev;
-#define ISFR_CLK	0
-#define IAHB_CLK	1
-#define CEC_CLK		2
-
-	struct clk *bulk_clks;
-	struct hdmi_data_info hdmi_data;
-	const struct dw_hdmi_plat_data *plat_data;
-	struct display_timing timings;
-	struct scdc scdc;
-	u32 max_tmds_clock;
-	int vic;
-
-	u8 edid[HDMI_EDID_LEN];
-
-	struct {
-		const struct dw_hdmi_phy_ops *ops;
-		const char *name;
-		void *data;
-		bool enabled;
-	} phy;
-
-	struct display_timing previous_mode;
-	struct udevice *ddc;
-	void __iomem *regs;
-	bool sink_is_hdmi;
-	bool sink_has_audio;
-
-	int force;
-	bool disabled;			/* DRM has disabled our bridge */
-	bool bridge_is_on;		/* indicates the bridge is on */
-	bool rxsense;			/* rxsense state */
-	u8 phy_mask;			/* desired phy int mask settings */
-	u8 mc_clkdis;			/* clock disable register */
-
-	unsigned int sample_non_pcm;
-	unsigned int sample_width;
-	unsigned int sample_rate;
-	unsigned int channels;
-	unsigned int audio_cts;
-	unsigned int audio_n;
-	bool audio_enable;
-
-	unsigned int reg_shift;
-	struct regmap *regm;
-	void (*enable_audio)(struct dw_hdmi *hdmi);
-	void (*disable_audio)(struct dw_hdmi *hdmi);
-
-	struct cec_notifier *cec_notifier;
-	struct device *codec_dev;
-	int last_connector_result;
-};
-
-#define HDMI_IH_PHY_STAT0_RX_SENSE \
-	(HDMI_IH_PHY_STAT0_RX_SENSE0 | HDMI_IH_PHY_STAT0_RX_SENSE1 | \
-	 HDMI_IH_PHY_STAT0_RX_SENSE2 | HDMI_IH_PHY_STAT0_RX_SENSE3)
-
-#define HDMI_PHY_RX_SENSE \
-	(HDMI_PHY_RX_SENSE0 | HDMI_PHY_RX_SENSE1 | \
-	 HDMI_PHY_RX_SENSE2 | HDMI_PHY_RX_SENSE3)
-
-static inline void hdmi_writeb(struct dw_hdmi *hdmi, u8 val, int offset)
-{
-	regmap_raw_write(hdmi->regm, offset << hdmi->reg_shift, &val, REGMAP_SIZE_8);
-}
-
-static inline u8 hdmi_readb(struct dw_hdmi *hdmi, int offset)
-{
-	unsigned int val = 0;
-
-	regmap_raw_read(hdmi->regm, offset << hdmi->reg_shift, &val, REGMAP_SIZE_8);
-
-	return val;
-}
-
-static void hdmi_modb(struct dw_hdmi *hdmi, u8 data, u8 mask, unsigned reg)
-{
-	unsigned val = hdmi_readb(hdmi, reg);
-
-	val &= ~mask;
-	val |= data;
-	hdmi_writeb(hdmi, val, reg);
-}
-
-static void hdmi_mask_writeb(struct dw_hdmi *hdmi, u8 data, unsigned int reg,
-			     u8 shift, u8 mask)
-{
-	hdmi_modb(hdmi, data << shift, mask, reg);
-}
-
-static void hdmi_set_cts_n(struct dw_hdmi *hdmi, unsigned int cts,
-			   unsigned int n)
-{
-	/* Must be set/cleared first */
-	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_CTS_MANUAL, HDMI_AUD_CTS3);
-
-	/* nshift factor = 0 */
-	hdmi_modb(hdmi, 0, HDMI_AUD_CTS3_N_SHIFT_MASK, HDMI_AUD_CTS3);
-
-	/* Use automatic CTS generation mode when CTS is not set */
-	if (cts)
-		hdmi_writeb(hdmi, ((cts >> 16) &
-				   HDMI_AUD_CTS3_AUDCTS19_16_MASK) |
-				  HDMI_AUD_CTS3_CTS_MANUAL,
-			    HDMI_AUD_CTS3);
-	else
-		hdmi_writeb(hdmi, 0, HDMI_AUD_CTS3);
-	hdmi_writeb(hdmi, (cts >> 8) & 0xff, HDMI_AUD_CTS2);
-	hdmi_writeb(hdmi, cts & 0xff, HDMI_AUD_CTS1);
-
-	hdmi_writeb(hdmi, (n >> 16) & 0x0f, HDMI_AUD_N3);
-	hdmi_writeb(hdmi, (n >> 8) & 0xff, HDMI_AUD_N2);
-	hdmi_writeb(hdmi, n & 0xff, HDMI_AUD_N1);
-}
-
-static unsigned int hdmi_compute_n(unsigned int freq, unsigned long pixel_clk)
-{
-	unsigned int n = (128 * freq) / 1000;
-	unsigned int mult = 1;
-
-	while (freq > 48000) {
-		mult *= 2;
-		freq /= 2;
-	}
-
-	switch (freq) {
-	case 32000:
-		if (pixel_clk == 25175000)
-			n = 4576;
-		else if (pixel_clk == 27027000)
-			n = 4096;
-		else if (pixel_clk == 74176000 || pixel_clk == 148352000)
-			n = 11648;
-		else if (pixel_clk == 297000000)
-			n = 3072;
-		else
-			n = 4096;
-		n *= mult;
-		break;
-
-	case 44100:
-		if (pixel_clk == 25175000)
-			n = 7007;
-		else if (pixel_clk == 74176000)
-			n = 17836;
-		else if (pixel_clk == 148352000)
-			n = 8918;
-		else if (pixel_clk == 297000000)
-			n = 4704;
-		else
-			n = 6272;
-		n *= mult;
-		break;
-
-	case 48000:
-		if (pixel_clk == 25175000)
-			n = 6864;
-		else if (pixel_clk == 27027000)
-			n = 6144;
-		else if (pixel_clk == 74176000)
-			n = 11648;
-		else if (pixel_clk == 148352000)
-			n = 5824;
-		else if (pixel_clk == 297000000)
-			n = 5120;
-		else
-			n = 6144;
-		n *= mult;
-		break;
-
-	default:
-		break;
-	}
-
-	return n;
-}
-
-static void hdmi_set_clk_regenerator(struct dw_hdmi *hdmi,
-	unsigned long pixel_clk, unsigned int sample_rate)
-{
-	unsigned long ftdms = pixel_clk;
-	unsigned int n, cts;
-	u8 config3;
-	u64 tmp;
-
-	n = hdmi_compute_n(sample_rate, pixel_clk);
-
-	config3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);
-
-	/* Only compute CTS when using internal AHB audio */
-	if ((config3 & HDMI_CONFIG3_AHBAUDDMA) || (config3 & HDMI_CONFIG3_GPAUD)) {
-		/*
-		 * Compute the CTS value from the N value.  Note that CTS and N
-		 * can be up to 20 bits in total, so we need 64-bit math.  Also
-		 * note that our TDMS clock is not fully accurate; it is
-		 * accurate to kHz.  This can introduce an unnecessary remainder
-		 * in the calculation below, so we don't try to warn about that.
-		 */
-		tmp = (u64)ftdms * n;
-		do_div(tmp, 128 * sample_rate);
-		cts = tmp;
-
-		dev_dbg(hdmi->dev, "%s: fs=%uHz ftdms=%lu.%03luMHz N=%d cts=%d\n",
-			__func__, sample_rate,
-			ftdms / 1000000, (ftdms / 1000) % 1000,
-			n, cts);
-	} else {
-		cts = 0;
-	}
-
-	hdmi->audio_n = n;
-	hdmi->audio_cts = cts;
-	hdmi_set_cts_n(hdmi, cts, hdmi->audio_enable ? n : 0);
-}
-
-static void hdmi_init_clk_regenerator(struct dw_hdmi *hdmi)
-{
-	hdmi_set_clk_regenerator(hdmi, 74250000, hdmi->sample_rate);
-}
-
-static void hdmi_clk_regenerator_update_pixel_clock(struct dw_hdmi *hdmi)
-{
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
-}
-
-void dw_hdmi_set_sample_width(struct dw_hdmi *hdmi, unsigned int width)
-{
-	hdmi->sample_width = width;
-}
-
-void dw_hdmi_set_sample_non_pcm(struct dw_hdmi *hdmi, unsigned int non_pcm)
-{
-	hdmi->sample_non_pcm = non_pcm;
-}
-
-void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate)
-{
-	hdmi->sample_rate = rate;
-	hdmi_set_clk_regenerator(hdmi, hdmi->hdmi_data.video_mode.mtmdsclock,
-				 hdmi->sample_rate);
-}
-
-void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt)
-{
-	u8 layout;
-
-	hdmi->channels = cnt;
-
-	/*
-	 * For >2 channel PCM audio, we need to select layout 1
-	 * and set an appropriate channel map.
-	 */
-	if (cnt > 2)
-		layout = HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1;
-	else
-		layout = HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0;
-
-	hdmi_modb(hdmi, layout, HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK,
-		  HDMI_FC_AUDSCONF);
-
-	/* Set the audio infoframes channel count */
-	hdmi_modb(hdmi, (cnt - 1) << HDMI_FC_AUDICONF0_CC_OFFSET,
-		  HDMI_FC_AUDICONF0_CC_MASK, HDMI_FC_AUDICONF0);
-}
-
-void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca)
-{
-	hdmi_writeb(hdmi, ca, HDMI_FC_AUDICONF2);
-}
-
-static void hdmi_enable_audio_clk(struct dw_hdmi *hdmi, bool enable)
-{
-	if (enable)
-		hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_AUDCLK_DISABLE;
-	else
-		hdmi->mc_clkdis |= HDMI_MC_CLKDIS_AUDCLK_DISABLE;
-	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
-}
-
-static bool hdmi_bus_fmt_is_rgb(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv444(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_YUV16_1X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv422(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static bool hdmi_bus_fmt_is_yuv420(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		return true;
-
-	default:
-		return false;
-	}
-}
-
-static int hdmi_bus_fmt_color_depth(unsigned int bus_format)
-{
-	switch (bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-		return 8;
-
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-		return 10;
-
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-		return 12;
-
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-	case MEDIA_BUS_FMT_YUV16_1X48:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		return 16;
-
-	default:
-		return 0;
-	}
-}
-
-/*
- * this submodule is responsible for the video data synchronization.
- * for example, for RGB 4:4:4 input, the data map is defined as
- *			pin{47~40} <==> R[7:0]
- *			pin{31~24} <==> G[7:0]
- *			pin{15~8}  <==> B[7:0]
- */
-static void hdmi_video_sample(struct dw_hdmi *hdmi)
-{
-	int color_format = 0;
-	u8 val;
-
-	switch (hdmi->hdmi_data.enc_in_bus_format) {
-	case MEDIA_BUS_FMT_RGB888_1X24:
-		color_format = 0x01;
-		break;
-	case MEDIA_BUS_FMT_RGB101010_1X30:
-		color_format = 0x03;
-		break;
-	case MEDIA_BUS_FMT_RGB121212_1X36:
-		color_format = 0x05;
-		break;
-	case MEDIA_BUS_FMT_RGB161616_1X48:
-		color_format = 0x07;
-		break;
-
-	case MEDIA_BUS_FMT_YUV8_1X24:
-	case MEDIA_BUS_FMT_UYYVYY8_0_5X24:
-		color_format = 0x09;
-		break;
-	case MEDIA_BUS_FMT_YUV10_1X30:
-	case MEDIA_BUS_FMT_UYYVYY10_0_5X30:
-		color_format = 0x0B;
-		break;
-	case MEDIA_BUS_FMT_YUV12_1X36:
-	case MEDIA_BUS_FMT_UYYVYY12_0_5X36:
-		color_format = 0x0D;
-		break;
-	case MEDIA_BUS_FMT_YUV16_1X48:
-	case MEDIA_BUS_FMT_UYYVYY16_0_5X48:
-		color_format = 0x0F;
-		break;
-
-	case MEDIA_BUS_FMT_UYVY8_1X16:
-		color_format = 0x16;
-		break;
-	case MEDIA_BUS_FMT_UYVY10_1X20:
-		color_format = 0x14;
-		break;
-	case MEDIA_BUS_FMT_UYVY12_1X24:
-		color_format = 0x12;
-		break;
-
-	default:
-		return;
-	}
-
-	val = HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE |
-		((color_format << HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET) &
-		HDMI_TX_INVID0_VIDEO_MAPPING_MASK);
-	hdmi_writeb(hdmi, val, HDMI_TX_INVID0);
-
-	/* Enable TX stuffing: When DE is inactive, fix the output data to 0 */
-	val = HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE |
-		HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE |
-		HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE;
-	hdmi_writeb(hdmi, val, HDMI_TX_INSTUFFING);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_GYDATA1);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_RCRDATA1);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA0);
-	hdmi_writeb(hdmi, 0x0, HDMI_TX_BCBDATA1);
-}
-
-static int is_color_space_conversion(struct dw_hdmi *hdmi)
-{
-	return hdmi->hdmi_data.enc_in_bus_format != hdmi->hdmi_data.enc_out_bus_format;
-}
-
-static int is_color_space_decimation(struct dw_hdmi *hdmi)
-{
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format))
-		return 0;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_in_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_in_bus_format))
-		return 1;
-
-	return 0;
-}
-
-static int is_color_space_interpolation(struct dw_hdmi *hdmi)
-{
-	if (!hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_in_bus_format))
-		return 0;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format))
-		return 1;
-
-	return 0;
-}
-
-static void dw_hdmi_update_csc_coeffs(struct dw_hdmi *hdmi)
-{
-	const u16 (*csc_coeff)[3][4] = &csc_coeff_default;
-	unsigned i;
-	u32 csc_scale = 1;
-
-	if (is_color_space_conversion(hdmi)) {
-		if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format)) {
-			if (hdmi->hdmi_data.enc_out_encoding ==
-						V4L2_YCBCR_ENC_601)
-				csc_coeff = &csc_coeff_rgb_out_eitu601;
-			else
-				csc_coeff = &csc_coeff_rgb_out_eitu709;
-		} else if (hdmi_bus_fmt_is_rgb(
-					hdmi->hdmi_data.enc_in_bus_format)) {
-			if (hdmi->hdmi_data.enc_out_encoding ==
-						V4L2_YCBCR_ENC_601)
-				csc_coeff = &csc_coeff_rgb_in_eitu601;
-			else
-				csc_coeff = &csc_coeff_rgb_in_eitu709;
-			csc_scale = 0;
-		}
-	}
-
-	/* The CSC registers are sequential, alternating MSB then LSB */
-	for (i = 0; i < ARRAY_SIZE(csc_coeff_default[0]); i++) {
-		u16 coeff_a = (*csc_coeff)[0][i];
-		u16 coeff_b = (*csc_coeff)[1][i];
-		u16 coeff_c = (*csc_coeff)[2][i];
-
-		hdmi_writeb(hdmi, coeff_a & 0xff, HDMI_CSC_COEF_A1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_a >> 8, HDMI_CSC_COEF_A1_MSB + i * 2);
-		hdmi_writeb(hdmi, coeff_b & 0xff, HDMI_CSC_COEF_B1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_b >> 8, HDMI_CSC_COEF_B1_MSB + i * 2);
-		hdmi_writeb(hdmi, coeff_c & 0xff, HDMI_CSC_COEF_C1_LSB + i * 2);
-		hdmi_writeb(hdmi, coeff_c >> 8, HDMI_CSC_COEF_C1_MSB + i * 2);
-	}
-
-	hdmi_modb(hdmi, csc_scale, HDMI_CSC_SCALE_CSCSCALE_MASK,
-		  HDMI_CSC_SCALE);
-}
-
-static void hdmi_video_csc(struct dw_hdmi *hdmi)
-{
-	int color_depth = 0;
-	int interpolation = HDMI_CSC_CFG_INTMODE_DISABLE;
-	int decimation = 0;
-
-	/* YCC422 interpolation to 444 mode */
-	if (is_color_space_interpolation(hdmi))
-		interpolation = HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1;
-	else if (is_color_space_decimation(hdmi))
-		decimation = HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3;
-
-	switch (hdmi_bus_fmt_color_depth(hdmi->hdmi_data.enc_out_bus_format)) {
-	case 8:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP;
-		break;
-	case 10:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP;
-		break;
-	case 12:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP;
-		break;
-	case 16:
-		color_depth = HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP;
-		break;
-
-	default:
-		return;
-	}
-
-	/* Configure the CSC registers */
-	hdmi_writeb(hdmi, interpolation | decimation, HDMI_CSC_CFG);
-	hdmi_modb(hdmi, color_depth, HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK,
-		  HDMI_CSC_SCALE);
-
-	dw_hdmi_update_csc_coeffs(hdmi);
-}
-
-/*
- * HDMI video packetizer is used to packetize the data.
- * for example, if input is YCC422 mode or repeater is used,
- * data should be repacked this module can be bypassed.
- */
-static void hdmi_video_packetize(struct dw_hdmi *hdmi)
-{
-	unsigned int color_depth = 0;
-	unsigned int remap_size = HDMI_VP_REMAP_YCC422_16bit;
-	unsigned int output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_PP;
-	struct hdmi_data_info *hdmi_data = &hdmi->hdmi_data;
-	u8 val, vp_conf;
-
-	if (hdmi_bus_fmt_is_rgb(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv444(hdmi->hdmi_data.enc_out_bus_format) ||
-	    hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
-		switch (hdmi_bus_fmt_color_depth(
-					hdmi->hdmi_data.enc_out_bus_format)) {
-		case 8:
-			color_depth = 4;
-			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
-			break;
-		case 10:
-			color_depth = 5;
-			break;
-		case 12:
-			color_depth = 6;
-			break;
-		case 16:
-			color_depth = 7;
-			break;
-		default:
-			output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS;
-		}
-	} else if (hdmi_bus_fmt_is_yuv422(hdmi->hdmi_data.enc_out_bus_format)) {
-		switch (hdmi_bus_fmt_color_depth(
-					hdmi->hdmi_data.enc_out_bus_format)) {
-		case 0:
-		case 8:
-			remap_size = HDMI_VP_REMAP_YCC422_16bit;
-			break;
-		case 10:
-			remap_size = HDMI_VP_REMAP_YCC422_20bit;
-			break;
-		case 12:
-			remap_size = HDMI_VP_REMAP_YCC422_24bit;
-			break;
-
-		default:
-			return;
-		}
-		output_select = HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422;
-	} else {
-		return;
-	}
-
-	/* set the packetizer registers */
-	val = ((color_depth << HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET) &
-		HDMI_VP_PR_CD_COLOR_DEPTH_MASK) |
-		((hdmi_data->pix_repet_factor <<
-		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET) &
-		HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK);
-	hdmi_writeb(hdmi, val, HDMI_VP_PR_CD);
-
-	val = hdmi_readb(hdmi, HDMI_FC_DATAUTO3);
-	if (color_depth == 4)
-		/* disable Auto GCP when bpp 24 */
-		val &= ~0x4;
-	else
-		val |= 0x4;
-	hdmi_writeb(hdmi, val, HDMI_FC_DATAUTO3);
-
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PR_STUFFING_MASK, HDMI_VP_STUFF);
-
-	/* Data from pixel repeater block */
-	if (hdmi_data->pix_repet_factor > 1) {
-		vp_conf = HDMI_VP_CONF_PR_EN_ENABLE |
-			  HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER;
-	} else { /* data from packetizer block */
-		vp_conf = HDMI_VP_CONF_PR_EN_DISABLE |
-			  HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER;
-	}
-
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_PR_EN_MASK |
-		  HDMI_VP_CONF_BYPASS_SELECT_MASK, HDMI_VP_CONF);
-
-	hdmi_modb(hdmi, 1 << HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET,
-		  HDMI_VP_STUFF_IDEFAULT_PHASE_MASK, HDMI_VP_STUFF);
-
-	hdmi_writeb(hdmi, remap_size, HDMI_VP_REMAP);
-
-	if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_PP) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
-			  HDMI_VP_CONF_PP_EN_ENABLE |
-			  HDMI_VP_CONF_YCC422_EN_DISABLE;
-	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_DISABLE |
-			  HDMI_VP_CONF_PP_EN_DISABLE |
-			  HDMI_VP_CONF_YCC422_EN_ENABLE;
-	} else if (output_select == HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS) {
-		vp_conf = HDMI_VP_CONF_BYPASS_EN_ENABLE |
-			  HDMI_VP_CONF_PP_EN_DISABLE |
-			  HDMI_VP_CONF_YCC422_EN_DISABLE;
-	} else {
-		return;
-	}
-
-	hdmi_modb(hdmi, vp_conf,
-		  HDMI_VP_CONF_BYPASS_EN_MASK | HDMI_VP_CONF_PP_EN_ENMASK |
-		  HDMI_VP_CONF_YCC422_EN_MASK, HDMI_VP_CONF);
-
-	hdmi_modb(hdmi, HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE |
-			HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE,
-		  HDMI_VP_STUFF_PP_STUFFING_MASK |
-		  HDMI_VP_STUFF_YCC422_STUFFING_MASK, HDMI_VP_STUFF);
-
-	hdmi_modb(hdmi, output_select, HDMI_VP_CONF_OUTPUT_SELECTOR_MASK,
-		  HDMI_VP_CONF);
-}
-
-/* -----------------------------------------------------------------------------
- * Synopsys PHY Handling
- */
-
-static inline void hdmi_phy_test_clear(struct dw_hdmi *hdmi,
-				       unsigned char bit)
-{
-	hdmi_modb(hdmi, bit << HDMI_PHY_TST0_TSTCLR_OFFSET,
-		  HDMI_PHY_TST0_TSTCLR_MASK, HDMI_PHY_TST0);
-}
-
-static bool hdmi_phy_wait_i2c_done(struct dw_hdmi *hdmi, int msec)
-{
-	u32 val;
-
-	while ((val = hdmi_readb(hdmi, HDMI_IH_I2CMPHY_STAT0) & 0x3) == 0) {
-		if (msec-- == 0)
-			return false;
-		udelay(1000);
-	}
-	hdmi_writeb(hdmi, val, HDMI_IH_I2CMPHY_STAT0);
-
-	return true;
-}
-
-void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
-			   unsigned char addr)
-{
-	hdmi_writeb(hdmi, 0xFF, HDMI_IH_I2CMPHY_STAT0);
-	hdmi_writeb(hdmi, addr, HDMI_PHY_I2CM_ADDRESS_ADDR);
-	hdmi_writeb(hdmi, (unsigned char)(data >> 8),
-		    HDMI_PHY_I2CM_DATAO_1_ADDR);
-	hdmi_writeb(hdmi, (unsigned char)(data >> 0),
-		    HDMI_PHY_I2CM_DATAO_0_ADDR);
-	hdmi_writeb(hdmi, HDMI_PHY_I2CM_OPERATION_ADDR_WRITE,
-		    HDMI_PHY_I2CM_OPERATION_ADDR);
-	hdmi_phy_wait_i2c_done(hdmi, 1000);
-}
-
-/* Filter out invalid setups to avoid configuring SCDC and scrambling */
-static bool dw_hdmi_support_scdc(struct dw_hdmi *hdmi)
-{
-	/* Completely disable SCDC support for older controllers */
-	if (hdmi->version < 0x200a)
-		return false;
-
-	/* Disable if no DDC bus */
-	if (!hdmi->ddc)
-		return false;
-
-	/* Disable if SCDC is not supported, or if an HF-VSDB block is absent */
-	if (!hdmi->scdc.supported ||
-	    !hdmi->scdc.scrambling_supported)
-		return false;
-
-	/*
-	 * Disable if display only support low TMDS rates and scrambling
-	 * for low rates is not supported either
-	 */
-	if (!hdmi->scdc.scrambling_low_rates &&
-	    hdmi->max_tmds_clock <= 340000)
-		return false;
-
-	return true;
-}
-
-/*
- * HDMI2.0 Specifies the following procedure for High TMDS Bit Rates:
- * - The Source shall suspend transmission of the TMDS clock and data
- * - The Source shall write to the TMDS_Bit_Clock_Ratio bit to change it
- * from a 0 to a 1 or from a 1 to a 0
- * - The Source shall allow a minimum of 1 ms and a maximum of 100 ms from
- * the time the TMDS_Bit_Clock_Ratio bit is written until resuming
- * transmission of TMDS clock and data
- *
- * To respect the 100ms maximum delay, the dw_hdmi_set_high_tmds_clock_ratio()
- * helper should called right before enabling the TMDS Clock and Data in
- * the PHY configuration callback.
- */
-#if 0
-void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi)
-{
-	unsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
-
-	/* Control for TMDS Bit Period/TMDS Clock-Period Ratio */
-	if (dw_hdmi_support_scdc(hdmi)) {
-		if (mtmdsclock > HDMI14_MAX_TMDSCLK)
-			drm_scdc_set_high_tmds_clock_ratio(hdmi->ddc, 1);
-		else
-			drm_scdc_set_high_tmds_clock_ratio(hdmi->ddc, 0);
-	}
-}
-#else
-void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi) {};
-#endif
-
-static void dw_hdmi_phy_enable_powerdown(struct dw_hdmi *hdmi, bool enable)
-{
-	hdmi_mask_writeb(hdmi, !enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_PDZ_OFFSET,
-			 HDMI_PHY_CONF0_PDZ_MASK);
-}
-
-static void dw_hdmi_phy_enable_tmds(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_ENTMDS_OFFSET,
-			 HDMI_PHY_CONF0_ENTMDS_MASK);
-}
-
-static void dw_hdmi_phy_enable_svsret(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SVSRET_OFFSET,
-			 HDMI_PHY_CONF0_SVSRET_MASK);
-}
-
-void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET,
-			 HDMI_PHY_CONF0_GEN2_PDDQ_MASK);
-}
-
-void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET,
-			 HDMI_PHY_CONF0_GEN2_TXPWRON_MASK);
-}
-
-static void dw_hdmi_phy_sel_data_en_pol(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SELDATAENPOL_OFFSET,
-			 HDMI_PHY_CONF0_SELDATAENPOL_MASK);
-}
-
-static void dw_hdmi_phy_sel_interface_control(struct dw_hdmi *hdmi, u8 enable)
-{
-	hdmi_mask_writeb(hdmi, enable, HDMI_PHY_CONF0,
-			 HDMI_PHY_CONF0_SELDIPIF_OFFSET,
-			 HDMI_PHY_CONF0_SELDIPIF_MASK);
-}
-
-void dw_hdmi_phy_reset(struct dw_hdmi *hdmi)
-{
-	/* PHY reset. The reset signal is active high on Gen1 PHYs. */
-	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
-	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
-}
-
-void dw_hdmi_phy_gen2_reset(struct dw_hdmi *hdmi)
-{
-	/* PHY reset. The reset signal is active high on Gen2 PHYs. */
-	hdmi_writeb(hdmi, HDMI_MC_PHYRSTZ_PHYRSTZ, HDMI_MC_PHYRSTZ);
-	hdmi_writeb(hdmi, 0, HDMI_MC_PHYRSTZ);
-}
-
-void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address)
-{
-	hdmi_phy_test_clear(hdmi, 1);
-	hdmi_writeb(hdmi, address, HDMI_PHY_I2CM_SLAVE_ADDR);
-	hdmi_phy_test_clear(hdmi, 0);
-}
-
-static void dw_hdmi_phy_power_off(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	unsigned int i;
-	u16 val;
-
-	if (phy->gen == 1) {
-		dw_hdmi_phy_enable_tmds(hdmi, 0);
-		dw_hdmi_phy_enable_powerdown(hdmi, true);
-		return;
-	}
-
-	dw_hdmi_phy_gen2_txpwron(hdmi, 0);
-
-	/*
-	 * Wait for TX_PHY_LOCK to be deasserted to indicate that the PHY went
-	 * to low power mode.
-	 */
-	for (i = 0; i < 5; ++i) {
-		val = hdmi_readb(hdmi, HDMI_PHY_STAT0);
-		if (!(val & HDMI_PHY_TX_PHY_LOCK))
-			break;
-
-		udelay(1000);
-	}
-
-	if (val & HDMI_PHY_TX_PHY_LOCK)
-		dev_warn(hdmi->dev, "PHY failed to power down\n");
-	else
-		dev_dbg(hdmi->dev, "PHY powered down in %u iterations\n", i);
-
-	dw_hdmi_phy_gen2_pddq(hdmi, 1);
-}
-
-static int dw_hdmi_phy_power_on(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	unsigned int i;
-	u8 val;
-
-	if (phy->gen == 1) {
-		dw_hdmi_phy_enable_powerdown(hdmi, false);
-
-		/* Toggle TMDS enable. */
-		dw_hdmi_phy_enable_tmds(hdmi, 0);
-		dw_hdmi_phy_enable_tmds(hdmi, 1);
-		return 0;
-	}
-
-	dw_hdmi_phy_gen2_txpwron(hdmi, 1);
-	dw_hdmi_phy_gen2_pddq(hdmi, 0);
-
-	/* Wait for PHY PLL lock */
-	for (i = 0; i < 5; ++i) {
-		val = hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_TX_PHY_LOCK;
-		if (val)
-			break;
-
-		udelay(1000);
-	}
-
-	if (!val) {
-		printf("PHY PLL failed to lock\n");
-		return -ETIMEDOUT;
-	}
-
-	dev_dbg(hdmi->dev, "PHY PLL locked %u iterations\n", i);
-	return 0;
-}
-
-/*
- * PHY configuration function for the DWC HDMI 3D TX PHY. Based on the available
- * information the DWC MHL PHY has the same register layout and is thus also
- * supported by this function.
- */
-static int hdmi_phy_configure_dwc_hdmi_3d_tx(struct dw_hdmi *hdmi,
-		const struct dw_hdmi_plat_data *pdata,
-		unsigned long mpixelclock)
-{
-	const struct dw_hdmi_mpll_config *mpll_config = pdata->mpll_cfg;
-	const struct dw_hdmi_curr_ctrl *curr_ctrl = pdata->cur_ctr;
-	const struct dw_hdmi_phy_config *phy_config = pdata->phy_config;
-
-	/* TOFIX Will need 420 specific PHY configuration tables */
-
-	/* PLL/MPLL Cfg - always match on final entry */
-	for (; mpll_config->mpixelclock != ~0UL; mpll_config++)
-		if (mpixelclock <= mpll_config->mpixelclock)
-			break;
-
-	for (; curr_ctrl->mpixelclock != ~0UL; curr_ctrl++)
-		if (mpixelclock <= curr_ctrl->mpixelclock)
-			break;
-
-	for (; phy_config->mpixelclock != ~0UL; phy_config++)
-		if (mpixelclock <= phy_config->mpixelclock)
-			break;
-
-	if (mpll_config->mpixelclock == ~0UL ||
-	    curr_ctrl->mpixelclock == ~0UL ||
-	    phy_config->mpixelclock == ~0UL)
-		return -EINVAL;
-
-	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[0].cpce,
-			      HDMI_3D_TX_PHY_CPCE_CTRL);
-	dw_hdmi_phy_i2c_write(hdmi, mpll_config->res[0].gmp,
-			      HDMI_3D_TX_PHY_GMPCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, curr_ctrl->curr[0],
-			      HDMI_3D_TX_PHY_CURRCTRL);
-
-	dw_hdmi_phy_i2c_write(hdmi, 0, HDMI_3D_TX_PHY_PLLPHBYCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK,
-			      HDMI_3D_TX_PHY_MSM_CTRL);
-
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->term, HDMI_3D_TX_PHY_TXTERM);
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->sym_ctr,
-			      HDMI_3D_TX_PHY_CKSYMTXCTRL);
-	dw_hdmi_phy_i2c_write(hdmi, phy_config->vlev_ctr,
-			      HDMI_3D_TX_PHY_VLEVCTRL);
-
-	/* Override and disable clock termination. */
-	dw_hdmi_phy_i2c_write(hdmi, HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE,
-			      HDMI_3D_TX_PHY_CKCALCTRL);
-
-	return 0;
-}
-
-static int hdmi_phy_configure(struct dw_hdmi *hdmi)
-{
-	const struct dw_hdmi_phy_data *phy = hdmi->phy.data;
-	const struct dw_hdmi_plat_data *pdata = hdmi->plat_data;
-	unsigned long mpixelclock = hdmi->hdmi_data.video_mode.mpixelclock;
-	unsigned long mtmdsclock = hdmi->hdmi_data.video_mode.mtmdsclock;
-	int ret;
-
-	dw_hdmi_phy_power_off(hdmi);
-
-	dw_hdmi_set_high_tmds_clock_ratio(hdmi);
-
-	/* Leave low power consumption mode by asserting SVSRET. */
-	if (phy->has_svsret)
-		dw_hdmi_phy_enable_svsret(hdmi, 1);
-
-	dw_hdmi_phy_gen2_reset(hdmi);
-
-	hdmi_writeb(hdmi, HDMI_MC_HEACPHY_RST_ASSERT, HDMI_MC_HEACPHY_RST);
-
-	dw_hdmi_phy_i2c_set_addr(hdmi, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
-
-	/* Write to the PHY as configured by the platform */
-	if (pdata->configure_phy)
-		ret = pdata->configure_phy(hdmi, pdata, mpixelclock);
-	else
-		ret = phy->configure(hdmi, pdata, mpixelclock);
-	if (ret) {
-		printf("PHY configuration failed (clock %lu)\n",
-			mpixelclock);
-		return ret;
-	}
-
-	/* Wait for resuming transmission of TMDS clock and data */
-	if (mtmdsclock > HDMI14_MAX_TMDSCLK)
-		mdelay(100);
-
-	return dw_hdmi_phy_power_on(hdmi);
-}
-
-static int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data, const struct display_timing *mode)
-{
-	int i, ret;
-
-	/* HDMI Phy spec says to do the phy initialization sequence twice */
-	for (i = 0; i < 2; i++) {
-		dw_hdmi_phy_sel_data_en_pol(hdmi, 1);
-		dw_hdmi_phy_sel_interface_control(hdmi, 0);
-
-		ret = hdmi_phy_configure(hdmi);
-		if (ret)
-			return ret;
-	}
-
-	return 0;
-}
-
-static void dw_hdmi_phy_disable(struct dw_hdmi *hdmi, void *data)
-{
-	dw_hdmi_phy_power_off(hdmi);
-}
-
-struct udevice* dw_hdmi_get_dev(struct dw_hdmi *hdmi)
-{
-	return hdmi->dev;
-}
-
-int dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi,
-					       void *data)
-{
-	return hdmi_readb(hdmi, HDMI_PHY_STAT0) & HDMI_PHY_HPD ?
-		1 : 0;
-}
-
-void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
-			    bool force, bool disabled, bool rxsense)
-{
-	u8 old_mask = hdmi->phy_mask;
-
-	if (force || disabled || !rxsense)
-		hdmi->phy_mask |= HDMI_PHY_RX_SENSE;
-	else
-		hdmi->phy_mask &= ~HDMI_PHY_RX_SENSE;
-
-	if (old_mask != hdmi->phy_mask)
-		hdmi_writeb(hdmi, hdmi->phy_mask, HDMI_PHY_MASK0);
-}
-
-void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data)
-{
-	/*
-	 * Configure the PHY RX SENSE and HPD interrupts polarities and clear
-	 * any pending interrupt.
-	 */
-	hdmi_writeb(hdmi, HDMI_PHY_HPD | HDMI_PHY_RX_SENSE, HDMI_PHY_POL0);
-	hdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,
-		    HDMI_IH_PHY_STAT0);
-
-	/* Enable cable hot plug irq. */
-	hdmi_writeb(hdmi, hdmi->phy_mask, HDMI_PHY_MASK0);
-
-	/* Clear and unmute interrupts. */
-	hdmi_writeb(hdmi, HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE,
-		    HDMI_IH_PHY_STAT0);
-	hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),
-		    HDMI_IH_MUTE_PHY_STAT0);
-}
-
-static const struct dw_hdmi_phy_ops dw_hdmi_synopsys_phy_ops = {
-	.init = dw_hdmi_phy_init,
-	.disable = dw_hdmi_phy_disable,
-	.read_hpd = dw_hdmi_phy_read_hpd,
-	.update_hpd = dw_hdmi_phy_update_hpd,
-	.setup_hpd = dw_hdmi_phy_setup_hpd,
-};
-
-/* -----------------------------------------------------------------------------
- * HDMI TX Setup
- */
-
-static void hdmi_tx_hdcp_config(struct dw_hdmi *hdmi)
-{
-	u8 de;
-
-	if (hdmi->hdmi_data.video_mode.mdataenablepolarity)
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH;
-	else
-		de = HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW;
-
-	/* disable rx detect */
-	hdmi_modb(hdmi, HDMI_A_HDCPCFG0_RXDETECT_DISABLE,
-		  HDMI_A_HDCPCFG0_RXDETECT_MASK, HDMI_A_HDCPCFG0);
-
-	hdmi_modb(hdmi, de, HDMI_A_VIDPOLCFG_DATAENPOL_MASK, HDMI_A_VIDPOLCFG);
-
-	hdmi_modb(hdmi, HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE,
-		  HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK, HDMI_A_HDCPCFG1);
-}
-
-#if 0
-static void hdmi_av_composer(struct dw_hdmi *hdmi, const struct display_timing *mode)
-{
-	u8 inv_val, bytes;
-	struct hdmi_vmode *vmode = &hdmi->hdmi_data.video_mode;
-	int hblank, vblank, h_de_hs, v_de_vs, hsync_len, vsync_len;
-	unsigned int vdisplay, hdisplay;
-	enum display_flags flags = mode->flags;
-
-	vmode->mtmdsclock = vmode->mpixelclock = mode->pixelclock.typ;
-
-	dev_dbg(hdmi->dev, "final pixclk = %d\n", vmode->mpixelclock);
-
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format))
-		vmode->mtmdsclock /= 2;
-
-	/* Set up HDMI_FC_INVIDCONF */
-	inv_val = (hdmi->hdmi_data.hdcp_enable ||
-		   (dw_hdmi_support_scdc(hdmi) &&
-		    (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||
-		     hdmi->scdc.scrambling_low_rates)) ?
-		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE :
-		HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE);
-
-	inv_val |= flags & DISPLAY_FLAGS_VSYNC_HIGH ?
-		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW;
-
-	inv_val |= flags & DISPLAY_FLAGS_HSYNC_HIGH ?
-		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW;
-
-	inv_val |= (vmode->mdataenablepolarity ?
-		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH :
-		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW);
-
-	if (hdmi->vic == 39)
-		inv_val |= HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH;
-	else
-		inv_val |= flags & DISPLAY_FLAGS_INTERLACED ?
-			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH :
-			HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW;
-
-	inv_val |= flags & DISPLAY_FLAGS_INTERLACED ?
-		HDMI_FC_INVIDCONF_IN_I_P_INTERLACED :
-		HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE;
-
-	inv_val |= hdmi->sink_is_hdmi ?
-		HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE :
-		HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE;
-
-	hdmi_writeb(hdmi, inv_val, HDMI_FC_INVIDCONF);
-
-	hdisplay = mode->hactive.typ;
-	hblank = mode->hfront_porch.typ + mode->hback_porch.typ + mode->hsync_len.typ;
-	h_de_hs = mode->hfront_porch.typ;
-	hsync_len = mode->hsync_len.typ;
-
-	/*
-	 * When we're setting a YCbCr420 mode, we need
-	 * to adjust the horizontal timing to suit.
-	 */
-	if (hdmi_bus_fmt_is_yuv420(hdmi->hdmi_data.enc_out_bus_format)) {
-		hdisplay /= 2;
-		hblank /= 2;
-		h_de_hs /= 2;
-		hsync_len /= 2;
-	}
-
-	vdisplay = mode->vactive.typ;
-	vblank = mode->vfront_porch.typ + mode->vback_porch.typ + mode->vsync_len.typ;
-	v_de_vs = mode->vfront_porch.typ;
-	vsync_len = mode->vsync_len.typ;
-
-	/*
-	 * When we're setting an interlaced mode, we need
-	 * to adjust the vertical timing to suit.
-	 */
-	if (flags & DISPLAY_FLAGS_INTERLACED) {
-		vdisplay /= 2;
-		vblank /= 2;
-		v_de_vs /= 2;
-		vsync_len /= 2;
-	}
-
-	/* Scrambling Control */
-	if (dw_hdmi_support_scdc(hdmi)) {
-		if (vmode->mtmdsclock > HDMI14_MAX_TMDSCLK ||
-		    hdmi->scdc.scrambling_low_rates) {
-			/*
-			 * HDMI2.0 Specifies the following procedure:
-			 * After the Source Device has determined that
-			 * SCDC_Present is set (=1), the Source Device should
-			 * write the accurate Version of the Source Device
-			 * to the Source Version field in the SCDCS.
-			 * Source Devices compliant shall set the
-			 * Source Version = 1.
-			 */
-			drm_scdc_readb(hdmi->ddc, SCDC_SINK_VERSION,
-				       &bytes);
-			drm_scdc_writeb(hdmi->ddc, SCDC_SOURCE_VERSION,
-				min_t(u8, bytes, SCDC_MIN_SOURCE_VERSION));
-
-			/* Enabled Scrambling in the Sink */
-			drm_scdc_set_scrambling(hdmi->ddc, 1);
-
-			/*
-			 * To activate the scrambler feature, you must ensure
-			 * that the quasi-static configuration bit
-			 * fc_invidconf.HDCP_keepout is set at configuration
-			 * time, before the required mc_swrstzreq.tmdsswrst_req
-			 * reset request is issued.
-			 */
-			hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
-				    HDMI_MC_SWRSTZ);
-			hdmi_writeb(hdmi, 1, HDMI_FC_SCRAMBLER_CTRL);
-		} else {
-			hdmi_writeb(hdmi, 0, HDMI_FC_SCRAMBLER_CTRL);
-			hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ,
-				    HDMI_MC_SWRSTZ);
-			drm_scdc_set_scrambling(hdmi->ddc, 0);
-		}
-	}
-
-	/* Set up horizontal active pixel width */
-	hdmi_writeb(hdmi, hdisplay >> 8, HDMI_FC_INHACTV1);
-	hdmi_writeb(hdmi, hdisplay, HDMI_FC_INHACTV0);
-
-	/* Set up vertical active lines */
-	hdmi_writeb(hdmi, vdisplay >> 8, HDMI_FC_INVACTV1);
-	hdmi_writeb(hdmi, vdisplay, HDMI_FC_INVACTV0);
-
-	/* Set up horizontal blanking pixel region width */
-	hdmi_writeb(hdmi, hblank >> 8, HDMI_FC_INHBLANK1);
-	hdmi_writeb(hdmi, hblank, HDMI_FC_INHBLANK0);
-
-	/* Set up vertical blanking pixel region width */
-	hdmi_writeb(hdmi, vblank, HDMI_FC_INVBLANK);
-
-	/* Set up HSYNC active edge delay width (in pixel clks) */
-	hdmi_writeb(hdmi, h_de_hs >> 8, HDMI_FC_HSYNCINDELAY1);
-	hdmi_writeb(hdmi, h_de_hs, HDMI_FC_HSYNCINDELAY0);
-
-	/* Set up VSYNC active edge delay (in lines) */
-	hdmi_writeb(hdmi, v_de_vs, HDMI_FC_VSYNCINDELAY);
-
-	/* Set up HSYNC active pulse width (in pixel clks) */
-	hdmi_writeb(hdmi, hsync_len >> 8, HDMI_FC_HSYNCINWIDTH1);
-	hdmi_writeb(hdmi, hsync_len, HDMI_FC_HSYNCINWIDTH0);
-
-	/* Set up VSYNC active edge delay (in lines) */
-	hdmi_writeb(hdmi, vsync_len, HDMI_FC_VSYNCINWIDTH);
-}
-#else
-static void hdmi_av_composer(struct dw_hdmi *hdmi, const struct display_timing *mode) {};
-#endif
-
-/* HDMI Initialization Step B.4 */
-static void dw_hdmi_enable_video_path(struct dw_hdmi *hdmi)
-{
-	/* control period minimum duration */
-	hdmi_writeb(hdmi, 12, HDMI_FC_CTRLDUR);
-	hdmi_writeb(hdmi, 32, HDMI_FC_EXCTRLDUR);
-	hdmi_writeb(hdmi, 1, HDMI_FC_EXCTRLSPAC);
-
-	/* Set to fill TMDS data channels */
-	hdmi_writeb(hdmi, 0x0B, HDMI_FC_CH0PREAM);
-	hdmi_writeb(hdmi, 0x16, HDMI_FC_CH1PREAM);
-	hdmi_writeb(hdmi, 0x21, HDMI_FC_CH2PREAM);
-
-	/* Enable pixel clock and tmds data path */
-	hdmi->mc_clkdis |= HDMI_MC_CLKDIS_HDCPCLK_DISABLE |
-			   HDMI_MC_CLKDIS_CSCCLK_DISABLE |
-			   HDMI_MC_CLKDIS_AUDCLK_DISABLE |
-			   HDMI_MC_CLKDIS_PREPCLK_DISABLE |
-			   HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
-	hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_PIXELCLK_DISABLE;
-	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
-
-	hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_TMDSCLK_DISABLE;
-	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
-
-	/* Enable csc path */
-	if (is_color_space_conversion(hdmi)) {
-		hdmi->mc_clkdis &= ~HDMI_MC_CLKDIS_CSCCLK_DISABLE;
-		hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
-	}
-
-	/* Enable color space conversion if needed */
-	if (is_color_space_conversion(hdmi))
-		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH,
-			    HDMI_MC_FLOWCTRL);
-	else
-		hdmi_writeb(hdmi, HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS,
-			    HDMI_MC_FLOWCTRL);
-}
-
-/* Workaround to clear the overflow condition */
-static void dw_hdmi_clear_overflow(struct dw_hdmi *hdmi)
-{
-	unsigned int count;
-	unsigned int i;
-	u8 val;
-
-	/*
-	 * Under some circumstances the Frame Composer arithmetic unit can miss
-	 * an FC register write due to being busy processing the previous one.
-	 * The issue can be worked around by issuing a TMDS software reset and
-	 * then write one of the FC registers several times.
-	 *
-	 * The number of iterations matters and depends on the HDMI TX revision
-	 * (and possibly on the platform). So far i.MX6Q (v1.30a), i.MX6DL
-	 * (v1.31a) and multiple Allwinner SoCs (v1.32a) have been identified
-	 * as needing the workaround, with 4 iterations for v1.30a and 1
-	 * iteration for others.
-	 * The Amlogic Meson GX SoCs (v2.01a) have been identified as needing
-	 * the workaround with a single iteration.
-	 * The Rockchip RK3288 SoC (v2.00a) and RK3328/RK3399 SoCs (v2.11a) have
-	 * been identified as needing the workaround with a single iteration.
-	 */
-
-	switch (hdmi->version) {
-	case 0x130a:
-		count = 4;
-		break;
-	case 0x131a:
-	case 0x132a:
-	case 0x200a:
-	case 0x201a:
-	case 0x211a:
-	case 0x212a:
-		count = 1;
-		break;
-	default:
-		return;
-	}
-
-	/* TMDS software reset */
-	hdmi_writeb(hdmi, (u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, HDMI_MC_SWRSTZ);
-
-	val = hdmi_readb(hdmi, HDMI_FC_INVIDCONF);
-	for (i = 0; i < count; i++)
-		hdmi_writeb(hdmi, val, HDMI_FC_INVIDCONF);
-}
-
-static void hdmi_disable_overflow_interrupts(struct dw_hdmi *hdmi)
-{
-	hdmi_writeb(hdmi, HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK,
-		    HDMI_IH_MUTE_FC_STAT2);
-}
-
-static int dw_hdmi_setup(struct dw_hdmi *hdmi, struct display_timing *mode)
-{
-	int ret;
-
-	hdmi_disable_overflow_interrupts(hdmi);
-
-	if ((hdmi->vic == 6) || (hdmi->vic == 7) ||
-	    (hdmi->vic == 21) || (hdmi->vic == 22) ||
-	    (hdmi->vic == 2) || (hdmi->vic == 3) ||
-	    (hdmi->vic == 17) || (hdmi->vic == 18))
-		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_601;
-	else
-		hdmi->hdmi_data.enc_out_encoding = V4L2_YCBCR_ENC_709;
-
-	hdmi->hdmi_data.video_mode.mpixelrepetitionoutput = 0;
-	hdmi->hdmi_data.video_mode.mpixelrepetitioninput = 0;
-
-	/* TOFIX: Get input format from plat data or fallback to RGB888 */
-	if (hdmi->plat_data->input_bus_format)
-		hdmi->hdmi_data.enc_in_bus_format =
-			hdmi->plat_data->input_bus_format;
-	else
-		hdmi->hdmi_data.enc_in_bus_format = MEDIA_BUS_FMT_RGB888_1X24;
-
-	/* TOFIX: Get input encoding from plat data or fallback to none */
-	if (hdmi->plat_data->input_bus_encoding)
-		hdmi->hdmi_data.enc_in_encoding =
-			hdmi->plat_data->input_bus_encoding;
-	else
-		hdmi->hdmi_data.enc_in_encoding = V4L2_YCBCR_ENC_DEFAULT;
-
-	/* TOFIX: Default to RGB888 output format */
-	hdmi->hdmi_data.enc_out_bus_format = MEDIA_BUS_FMT_RGB888_1X24;
-
-	hdmi->hdmi_data.pix_repet_factor = 0;
-	hdmi->hdmi_data.hdcp_enable = 0;
-	hdmi->hdmi_data.video_mode.mdataenablepolarity = true;
-
-	/* HDMI Initialization Step B.1 */
-	hdmi_av_composer(hdmi, mode);
-
-	/* HDMI Initializateion Step B.2 */
-	ret = hdmi->phy.ops->init(hdmi, hdmi->phy.data, &hdmi->previous_mode);
-	if (ret)
-		return ret;
-	hdmi->phy.enabled = true;
-
-	/* HDMI Initialization Step B.3 */
-	dw_hdmi_enable_video_path(hdmi);
-
-	if (hdmi->sink_has_audio) {
-		dev_dbg(hdmi->dev, "sink has audio support\n");
-
-		/* HDMI Initialization Step E - Configure audio */
-		hdmi_clk_regenerator_update_pixel_clock(hdmi);
-		hdmi_enable_audio_clk(hdmi, hdmi->audio_enable);
-	}
-
-	/* not for DVI mode */
-	if (hdmi->sink_is_hdmi) {
-		dev_dbg(hdmi->dev, "%s HDMI mode\n", __func__);
-	} else {
-		dev_dbg(hdmi->dev, "%s DVI mode\n", __func__);
-	}
-
-	hdmi_video_packetize(hdmi);
-	hdmi_video_csc(hdmi);
-	hdmi_video_sample(hdmi);
-	hdmi_tx_hdcp_config(hdmi);
-
-	dw_hdmi_clear_overflow(hdmi);
-
-	return 0;
-}
-
-static void initialize_hdmi_ih_mutes(struct dw_hdmi *hdmi)
-{
-	u8 ih_mute;
-
-	/*
-	 * Boot up defaults are:
-	 * HDMI_IH_MUTE   = 0x03 (disabled)
-	 * HDMI_IH_MUTE_* = 0x00 (enabled)
-	 *
-	 * Disable top level interrupt bits in HDMI block
-	 */
-	ih_mute = hdmi_readb(hdmi, HDMI_IH_MUTE) |
-		  HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
-		  HDMI_IH_MUTE_MUTE_ALL_INTERRUPT;
-
-	hdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);
-
-	/* by default mask all interrupts */
-	hdmi_writeb(hdmi, 0xff, HDMI_VP_MASK);
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK0);
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK1);
-	hdmi_writeb(hdmi, 0xff, HDMI_FC_MASK2);
-	hdmi_writeb(hdmi, 0xff, HDMI_PHY_MASK0);
-	hdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_INT_ADDR);
-	hdmi_writeb(hdmi, 0xff, HDMI_PHY_I2CM_CTLINT_ADDR);
-	hdmi_writeb(hdmi, 0xff, HDMI_AUD_INT);
-	hdmi_writeb(hdmi, 0xff, HDMI_AUD_SPDIFINT);
-	hdmi_writeb(hdmi, 0xff, HDMI_AUD_HBR_MASK);
-	hdmi_writeb(hdmi, 0xff, HDMI_GP_MASK);
-	hdmi_writeb(hdmi, 0xff, HDMI_A_APIINTMSK);
-
-	/* Disable interrupts in the IH_MUTE_* registers */
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT1);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_FC_STAT2);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AS_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_PHY_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CM_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_CEC_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_VP_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_I2CMPHY_STAT0);
-	hdmi_writeb(hdmi, 0xff, HDMI_IH_MUTE_AHBDMAAUD_STAT0);
-
-	/* Enable top level interrupt bits in HDMI block */
-	ih_mute &= ~(HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT |
-		    HDMI_IH_MUTE_MUTE_ALL_INTERRUPT);
-	hdmi_writeb(hdmi, ih_mute, HDMI_IH_MUTE);
-}
-
-static void dw_hdmi_poweron(struct dw_hdmi *hdmi)
-{
-	hdmi->bridge_is_on = true;
-	dw_hdmi_setup(hdmi, &hdmi->previous_mode);
-}
-
-static void dw_hdmi_poweroff(struct dw_hdmi *hdmi)
-{
-	if (hdmi->phy.enabled) {
-		hdmi->phy.ops->disable(hdmi, hdmi->phy.data);
-		hdmi->phy.enabled = false;
-	}
-
-	hdmi->bridge_is_on = false;
-}
-
-enum drm_connector_force {
-	DRM_FORCE_UNSPECIFIED,
-	DRM_FORCE_OFF,
-	DRM_FORCE_ON,		/* force on analog part normally */
-	DRM_FORCE_ON_DIGITAL,	/* for DVI-I use digital connector */
-};
-
-static void dw_hdmi_update_power(struct dw_hdmi *hdmi)
-{
-	int force = hdmi->force;
-
-	if (hdmi->disabled) {
-		force = DRM_FORCE_OFF;
-	} else if (force == DRM_FORCE_UNSPECIFIED) {
-		if (hdmi->rxsense)
-			force = DRM_FORCE_ON;
-		else
-			force = DRM_FORCE_OFF;
-	}
-
-	if (force == DRM_FORCE_OFF) {
-		if (hdmi->bridge_is_on)
-			dw_hdmi_poweroff(hdmi);
-	} else {
-		if (!hdmi->bridge_is_on)
-			dw_hdmi_poweron(hdmi);
-	}
-}
-
-/*
- * Adjust the detection of RXSENSE according to whether we have a forced
- * connection mode enabled, or whether we have been disabled.  There is
- * no point processing RXSENSE interrupts if we have a forced connection
- * state, or DRM has us disabled.
- *
- * We also disable rxsense interrupts when we think we're disconnected
- * to avoid floating TDMS signals giving false rxsense interrupts.
- *
- * Note: we still need to listen for HPD interrupts even when DRM has us
- * disabled so that we can detect a connect event.
- */
-static void dw_hdmi_update_phy_mask(struct dw_hdmi *hdmi)
-{
-	if (hdmi->phy.ops->update_hpd)
-		hdmi->phy.ops->update_hpd(hdmi, hdmi->phy.data,
-					  hdmi->force, hdmi->disabled,
-					  hdmi->rxsense);
-}
-
-void dw_hdmi_bridge_disable(struct dw_hdmi *hdmi)
-{
-	hdmi->disabled = true;
-	dw_hdmi_update_power(hdmi);
-	dw_hdmi_update_phy_mask(hdmi);
-}
-
-void dw_hdmi_bridge_enable(struct dw_hdmi *hdmi)
-{
-	hdmi->disabled = false;
-	dw_hdmi_update_power(hdmi);
-	dw_hdmi_update_phy_mask(hdmi);
-}
-
-irqreturn_t dw_hdmi_hardirq(int irq, void *dev_id)
-{
-	struct dw_hdmi *hdmi = dev_id;
-	u8 intr_stat;
-	irqreturn_t ret = IRQ_NONE;
-
-	intr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);
-	if (intr_stat) {
-		hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
-		return IRQ_WAKE_THREAD;
-	}
-
-	return ret;
-}
-
-void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense)
-{
-	if (!hdmi->force) {
-		/*
-		 * If the RX sense status indicates we're disconnected,
-		 * clear the software rxsense status.
-		 */
-		if (!rx_sense)
-			hdmi->rxsense = false;
-
-		/*
-		 * Only set the software rxsense status when both
-		 * rxsense and hpd indicates we're connected.
-		 * This avoids what seems to be bad behaviour in
-		 * at least iMX6S versions of the phy.
-		 */
-		if (hpd)
-			hdmi->rxsense = true;
-
-		dw_hdmi_update_power(hdmi);
-		dw_hdmi_update_phy_mask(hdmi);
-	}
-}
-
-int dw_hdmi_irq(int irq, void *dev_id)
-{
-	struct dw_hdmi *hdmi = dev_id;
-	u8 intr_stat, phy_int_pol, phy_pol_mask, phy_stat;
-
-	intr_stat = hdmi_readb(hdmi, HDMI_IH_PHY_STAT0);
-	phy_int_pol = hdmi_readb(hdmi, HDMI_PHY_POL0);
-	phy_stat = hdmi_readb(hdmi, HDMI_PHY_STAT0);
-
-	phy_pol_mask = 0;
-	if (intr_stat & HDMI_IH_PHY_STAT0_HPD)
-		phy_pol_mask |= HDMI_PHY_HPD;
-	if (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE0)
-		phy_pol_mask |= HDMI_PHY_RX_SENSE0;
-	if (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE1)
-		phy_pol_mask |= HDMI_PHY_RX_SENSE1;
-	if (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE2)
-		phy_pol_mask |= HDMI_PHY_RX_SENSE2;
-	if (intr_stat & HDMI_IH_PHY_STAT0_RX_SENSE3)
-		phy_pol_mask |= HDMI_PHY_RX_SENSE3;
-
-	if (phy_pol_mask)
-		hdmi_modb(hdmi, ~phy_int_pol, phy_pol_mask, HDMI_PHY_POL0);
-
-	/*
-	 * RX sense tells us whether the TDMS transmitters are detecting
-	 * load - in other words, there's something listening on the
-	 * other end of the link.  Use this to decide whether we should
-	 * power on the phy as HPD may be toggled by the sink to merely
-	 * ask the source to re-read the EDID.
-	 */
-	if (intr_stat &
-	    (HDMI_IH_PHY_STAT0_RX_SENSE | HDMI_IH_PHY_STAT0_HPD)) {
-		dw_hdmi_setup_rx_sense(hdmi,
-				       phy_stat & HDMI_PHY_HPD,
-				       phy_stat & HDMI_PHY_RX_SENSE);
-	}
-
-	if (intr_stat & HDMI_IH_PHY_STAT0_HPD) {
-		dev_dbg(hdmi->dev, "EVENT=%s\n",
-			phy_int_pol & HDMI_PHY_HPD ? "plugin" : "plugout");
-	}
-
-	hdmi_writeb(hdmi, intr_stat, HDMI_IH_PHY_STAT0);
-	hdmi_writeb(hdmi, ~(HDMI_IH_PHY_STAT0_HPD | HDMI_IH_PHY_STAT0_RX_SENSE),
-		    HDMI_IH_MUTE_PHY_STAT0);
-
-	return IRQ_HANDLED;
-}
-
-static const struct dw_hdmi_phy_data dw_hdmi_phys[] = {
-	{
-		.type = DW_HDMI_PHY_DWC_HDMI_TX_PHY,
-		.name = "DWC HDMI TX PHY",
-		.gen = 1,
-	}, {
-		.type = DW_HDMI_PHY_DWC_MHL_PHY_HEAC,
-		.name = "DWC MHL PHY + HEAC PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_MHL_PHY,
-		.name = "DWC MHL PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC,
-		.name = "DWC HDMI 3D TX PHY + HEAC PHY",
-		.gen = 2,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY,
-		.name = "DWC HDMI 3D TX PHY",
-		.gen = 2,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_DWC_HDMI20_TX_PHY,
-		.name = "DWC HDMI 2.0 TX PHY",
-		.gen = 2,
-		.has_svsret = true,
-		.configure = hdmi_phy_configure_dwc_hdmi_3d_tx,
-	}, {
-		.type = DW_HDMI_PHY_VENDOR_PHY,
-		.name = "Vendor PHY",
-	}
-};
-
-static int dw_hdmi_detect_phy(struct dw_hdmi *hdmi)
-{
-	unsigned int i;
-	u8 phy_type;
-
-	phy_type = hdmi->plat_data->phy_force_vendor ?
-				DW_HDMI_PHY_VENDOR_PHY :
-				hdmi_readb(hdmi, HDMI_CONFIG2_ID);
-
-	if (phy_type == DW_HDMI_PHY_VENDOR_PHY) {
-		/* Vendor PHYs require support from the glue layer. */
-		if (!hdmi->plat_data->phy_ops || !hdmi->plat_data->phy_name) {
-			printf("Vendor HDMI PHY not supported by glue layer\n");
-			return -ENODEV;
-		}
-
-		hdmi->phy.ops = hdmi->plat_data->phy_ops;
-		hdmi->phy.data = NULL;
-		hdmi->phy.name = hdmi->plat_data->phy_name;
-		return 0;
-	}
-
-	/* Synopsys PHYs are handled internally. */
-	for (i = 0; i < ARRAY_SIZE(dw_hdmi_phys); ++i) {
-		if (dw_hdmi_phys[i].type == phy_type) {
-			hdmi->phy.ops = &dw_hdmi_synopsys_phy_ops;
-			hdmi->phy.name = dw_hdmi_phys[i].name;
-			hdmi->phy.data = (void *)&dw_hdmi_phys[i];
-
-			if (!dw_hdmi_phys[i].configure &&
-			    !hdmi->plat_data->configure_phy) {
-				printf("%s requires platform support\n",
-					hdmi->phy.name);
-				return -ENODEV;
-			}
-
-			return 0;
-		}
-	}
-
-	printf("Unsupported HDMI PHY type (%02x)\n", phy_type);
-	return -ENODEV;
-}
-
-static void dw_hdmi_init_hw(struct dw_hdmi *hdmi)
-{
-	initialize_hdmi_ih_mutes(hdmi);
-
-	if (hdmi->phy.ops->setup_hpd)
-		hdmi->phy.ops->setup_hpd(hdmi, hdmi->phy.data);
-}
-
-static const char* const bulk_clock_names[] = {"isfr", "iahb", "cec"};
-
-static struct dw_hdmi * __dw_hdmi_probe(struct udevice *dev,
-		const struct dw_hdmi_plat_data *plat_data)
-{
-	ofnode np = dev_ofnode(dev);
-	struct dw_hdmi *hdmi;
-	struct udevice *ddc;
-	int ret, i;
-	u8 prod_id0;
-	u8 prod_id1;
-	u8 config0;
-	u8 config3;
-
-	ret = uclass_get_device_by_ofnode_prop(UCLASS_I2C, np,
-			"ddc-i2c-bus", &ddc);
-	if (ret && (ret != -ENOENT)) {
-		printf("failed to get ddc-i2c-bus device (%d)\n", ret);
-		return ERR_PTR(ret);
-	}
-
-	hdmi = kzalloc(sizeof(*hdmi), GFP_KERNEL);
-	if (!hdmi)
-		return ERR_PTR(-ENOMEM);
-
-	hdmi->plat_data = plat_data;
-	hdmi->dev = dev;
-	hdmi->sample_rate = 48000;
-	hdmi->channels = 2;
-	hdmi->disabled = true;
-	hdmi->rxsense = true;
-	hdmi->phy_mask = (u8)~(HDMI_PHY_HPD | HDMI_PHY_RX_SENSE);
-	hdmi->mc_clkdis = 0x7f;
-	hdmi->last_connector_result = 0;
-	hdmi->ddc = ddc;
-
-	if (!plat_data->regm) {
-		ret = regmap_init_mem(np, &hdmi->regm);
-		if (ret) {
-			printf("%s: Couldn't create regmap\n", __func__);
-			goto err_res;
-		}
-	} else {
-		hdmi->regm = plat_data->regm;
-	}
-	ret = devm_clk_get_enable_bulk(dev, bulk_clock_names,
-			ARRAY_SIZE(bulk_clock_names), 4, &hdmi->bulk_clks);
-	if (ret)
-		goto clks_disable;
-
-
-	/* Product and revision IDs */
-	hdmi->version = (hdmi_readb(hdmi, HDMI_DESIGN_ID) << 8)
-		      | (hdmi_readb(hdmi, HDMI_REVISION_ID) << 0);
-	prod_id0 = hdmi_readb(hdmi, HDMI_PRODUCT_ID0);
-	prod_id1 = hdmi_readb(hdmi, HDMI_PRODUCT_ID1);
-
-	if (prod_id0 != HDMI_PRODUCT_ID0_HDMI_TX ||
-	    (prod_id1 & ~HDMI_PRODUCT_ID1_HDCP) != HDMI_PRODUCT_ID1_HDMI_TX) {
-		dev_err(dev, "Unsupported HDMI controller (%04x:%02x:%02x)\n",
-			hdmi->version, prod_id0, prod_id1);
-		ret = -ENODEV;
-		goto clks_disable;
-	}
-
-	ret = dw_hdmi_detect_phy(hdmi);
-	if (ret < 0)
-		goto clks_disable;
-
-	printf("\nDetected HDMI TX controller v%x.%03x %s HDCP (%s)\n",
-		 hdmi->version >> 12, hdmi->version & 0xfff,
-		 prod_id1 & HDMI_PRODUCT_ID1_HDCP ? "with" : "without",
-		 hdmi->phy.name);
-
-	dw_hdmi_init_hw(hdmi);
-
-	/*
-	 * To prevent overflows in HDMI_IH_FC_STAT2, set the clk regenerator
-	 * N and cts values before enabling phy
-	 */
-	hdmi_init_clk_regenerator(hdmi);
-
-	config0 = hdmi_readb(hdmi, HDMI_CONFIG0_ID);
-	config3 = hdmi_readb(hdmi, HDMI_CONFIG3_ID);
-
-	return hdmi;
-
-clks_disable:
-	if (hdmi->bulk_clks) {
-		for (i = ARRAY_SIZE(bulk_clock_names) - 1; i >= 0; i--) {
-			if (hdmi->bulk_clks[i].dev)
-				clk_disable_unprepare(&hdmi->bulk_clks[i]);
-		}
-	}
-err_res:
-	return ERR_PTR(ret);
-}
-
-static void __dw_hdmi_remove(struct dw_hdmi *hdmi)
-{
-	int i;
-
-	/* Disable all interrupts */
-	hdmi_writeb(hdmi, ~0, HDMI_IH_MUTE_PHY_STAT0);
-
-	if (hdmi->bulk_clks) {
-		for (i = ARRAY_SIZE(bulk_clock_names) - 1; i >= 0; i--) {
-			if (hdmi->bulk_clks[i].dev)
-				clk_disable_unprepare(&hdmi->bulk_clks[i]);
-		}
-	}
-}
-
-/* -----------------------------------------------------------------------------
- * Probe/remove API, used from platforms based on the DRM bridge API.
- */
-struct dw_hdmi *dw_hdmi_probe(struct udevice *dev,
-			      const struct dw_hdmi_plat_data *plat_data)
-{
-	struct dw_hdmi *hdmi;
-
-	hdmi = __dw_hdmi_probe(dev, plat_data);
-	if (IS_ERR(hdmi))
-		return hdmi;
-
-
-	return hdmi;
-}
-
-void dw_hdmi_remove(struct dw_hdmi *hdmi)
-{
-	__dw_hdmi_remove(hdmi);
-}
-
-/* -----------------------------------------------------------------------------
- * Bind/unbind API, used from platforms based on the component framework.
- */
-struct dw_hdmi *dw_hdmi_bind(struct udevice *dev,
-			     const struct dw_hdmi_plat_data *plat_data)
-{
-	struct dw_hdmi *hdmi;
-
-	hdmi = __dw_hdmi_probe(dev, plat_data);
-	if (IS_ERR(hdmi))
-		return hdmi;
-
-	return hdmi;
-}
-
-void dw_hdmi_unbind(struct dw_hdmi *hdmi)
-{
-	__dw_hdmi_remove(hdmi);
-}
-
-void dw_hdmi_resume(struct dw_hdmi *hdmi)
-{
-	dw_hdmi_init_hw(hdmi);
-}
diff --git a/drivers/video/nxp/imx/dw/dw-hdmi.h b/drivers/video/nxp/imx/dw/dw-hdmi.h
deleted file mode 100644
index 8f6daa55fc..0000000000
--- a/drivers/video/nxp/imx/dw/dw-hdmi.h
+++ /dev/null
@@ -1,1128 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
- */
-
-#ifndef __DW_HDMI_H__
-#define __DW_HDMI_H__
-
-/* Identification Registers */
-#define HDMI_DESIGN_ID                          0x0000
-#define HDMI_REVISION_ID                        0x0001
-#define HDMI_PRODUCT_ID0                        0x0002
-#define HDMI_PRODUCT_ID1                        0x0003
-#define HDMI_CONFIG0_ID                         0x0004
-#define HDMI_CONFIG1_ID                         0x0005
-#define HDMI_CONFIG2_ID                         0x0006
-#define HDMI_CONFIG3_ID                         0x0007
-
-/* Interrupt Registers */
-#define HDMI_IH_FC_STAT0                        0x0100
-#define HDMI_IH_FC_STAT1                        0x0101
-#define HDMI_IH_FC_STAT2                        0x0102
-#define HDMI_IH_AS_STAT0                        0x0103
-#define HDMI_IH_PHY_STAT0                       0x0104
-#define HDMI_IH_I2CM_STAT0                      0x0105
-#define HDMI_IH_CEC_STAT0                       0x0106
-#define HDMI_IH_VP_STAT0                        0x0107
-#define HDMI_IH_I2CMPHY_STAT0                   0x0108
-#define HDMI_IH_AHBDMAAUD_STAT0                 0x0109
-
-#define HDMI_IH_MUTE_FC_STAT0                   0x0180
-#define HDMI_IH_MUTE_FC_STAT1                   0x0181
-#define HDMI_IH_MUTE_FC_STAT2                   0x0182
-#define HDMI_IH_MUTE_AS_STAT0                   0x0183
-#define HDMI_IH_MUTE_PHY_STAT0                  0x0184
-#define HDMI_IH_MUTE_I2CM_STAT0                 0x0185
-#define HDMI_IH_MUTE_CEC_STAT0                  0x0186
-#define HDMI_IH_MUTE_VP_STAT0                   0x0187
-#define HDMI_IH_MUTE_I2CMPHY_STAT0              0x0188
-#define HDMI_IH_MUTE_AHBDMAAUD_STAT0            0x0189
-#define HDMI_IH_MUTE                            0x01FF
-
-/* Video Sample Registers */
-#define HDMI_TX_INVID0                          0x0200
-#define HDMI_TX_INSTUFFING                      0x0201
-#define HDMI_TX_GYDATA0                         0x0202
-#define HDMI_TX_GYDATA1                         0x0203
-#define HDMI_TX_RCRDATA0                        0x0204
-#define HDMI_TX_RCRDATA1                        0x0205
-#define HDMI_TX_BCBDATA0                        0x0206
-#define HDMI_TX_BCBDATA1                        0x0207
-
-/* Video Packetizer Registers */
-#define HDMI_VP_STATUS                          0x0800
-#define HDMI_VP_PR_CD                           0x0801
-#define HDMI_VP_STUFF                           0x0802
-#define HDMI_VP_REMAP                           0x0803
-#define HDMI_VP_CONF                            0x0804
-#define HDMI_VP_STAT                            0x0805
-#define HDMI_VP_INT                             0x0806
-#define HDMI_VP_MASK                            0x0807
-#define HDMI_VP_POL                             0x0808
-
-/* Frame Composer Registers */
-#define HDMI_FC_INVIDCONF                       0x1000
-#define HDMI_FC_INHACTV0                        0x1001
-#define HDMI_FC_INHACTV1                        0x1002
-#define HDMI_FC_INHBLANK0                       0x1003
-#define HDMI_FC_INHBLANK1                       0x1004
-#define HDMI_FC_INVACTV0                        0x1005
-#define HDMI_FC_INVACTV1                        0x1006
-#define HDMI_FC_INVBLANK                        0x1007
-#define HDMI_FC_HSYNCINDELAY0                   0x1008
-#define HDMI_FC_HSYNCINDELAY1                   0x1009
-#define HDMI_FC_HSYNCINWIDTH0                   0x100A
-#define HDMI_FC_HSYNCINWIDTH1                   0x100B
-#define HDMI_FC_VSYNCINDELAY                    0x100C
-#define HDMI_FC_VSYNCINWIDTH                    0x100D
-#define HDMI_FC_INFREQ0                         0x100E
-#define HDMI_FC_INFREQ1                         0x100F
-#define HDMI_FC_INFREQ2                         0x1010
-#define HDMI_FC_CTRLDUR                         0x1011
-#define HDMI_FC_EXCTRLDUR                       0x1012
-#define HDMI_FC_EXCTRLSPAC                      0x1013
-#define HDMI_FC_CH0PREAM                        0x1014
-#define HDMI_FC_CH1PREAM                        0x1015
-#define HDMI_FC_CH2PREAM                        0x1016
-#define HDMI_FC_AVICONF3                        0x1017
-#define HDMI_FC_GCP                             0x1018
-#define HDMI_FC_AVICONF0                        0x1019
-#define HDMI_FC_AVICONF1                        0x101A
-#define HDMI_FC_AVICONF2                        0x101B
-#define HDMI_FC_AVIVID                          0x101C
-#define HDMI_FC_AVIETB0                         0x101D
-#define HDMI_FC_AVIETB1                         0x101E
-#define HDMI_FC_AVISBB0                         0x101F
-#define HDMI_FC_AVISBB1                         0x1020
-#define HDMI_FC_AVIELB0                         0x1021
-#define HDMI_FC_AVIELB1                         0x1022
-#define HDMI_FC_AVISRB0                         0x1023
-#define HDMI_FC_AVISRB1                         0x1024
-#define HDMI_FC_AUDICONF0                       0x1025
-#define HDMI_FC_AUDICONF1                       0x1026
-#define HDMI_FC_AUDICONF2                       0x1027
-#define HDMI_FC_AUDICONF3                       0x1028
-#define HDMI_FC_VSDIEEEID0                      0x1029
-#define HDMI_FC_VSDSIZE                         0x102A
-#define HDMI_FC_VSDIEEEID1                      0x1030
-#define HDMI_FC_VSDIEEEID2                      0x1031
-#define HDMI_FC_VSDPAYLOAD0                     0x1032
-#define HDMI_FC_VSDPAYLOAD1                     0x1033
-#define HDMI_FC_VSDPAYLOAD2                     0x1034
-#define HDMI_FC_VSDPAYLOAD3                     0x1035
-#define HDMI_FC_VSDPAYLOAD4                     0x1036
-#define HDMI_FC_VSDPAYLOAD5                     0x1037
-#define HDMI_FC_VSDPAYLOAD6                     0x1038
-#define HDMI_FC_VSDPAYLOAD7                     0x1039
-#define HDMI_FC_VSDPAYLOAD8                     0x103A
-#define HDMI_FC_VSDPAYLOAD9                     0x103B
-#define HDMI_FC_VSDPAYLOAD10                    0x103C
-#define HDMI_FC_VSDPAYLOAD11                    0x103D
-#define HDMI_FC_VSDPAYLOAD12                    0x103E
-#define HDMI_FC_VSDPAYLOAD13                    0x103F
-#define HDMI_FC_VSDPAYLOAD14                    0x1040
-#define HDMI_FC_VSDPAYLOAD15                    0x1041
-#define HDMI_FC_VSDPAYLOAD16                    0x1042
-#define HDMI_FC_VSDPAYLOAD17                    0x1043
-#define HDMI_FC_VSDPAYLOAD18                    0x1044
-#define HDMI_FC_VSDPAYLOAD19                    0x1045
-#define HDMI_FC_VSDPAYLOAD20                    0x1046
-#define HDMI_FC_VSDPAYLOAD21                    0x1047
-#define HDMI_FC_VSDPAYLOAD22                    0x1048
-#define HDMI_FC_VSDPAYLOAD23                    0x1049
-#define HDMI_FC_SPDVENDORNAME0                  0x104A
-#define HDMI_FC_SPDVENDORNAME1                  0x104B
-#define HDMI_FC_SPDVENDORNAME2                  0x104C
-#define HDMI_FC_SPDVENDORNAME3                  0x104D
-#define HDMI_FC_SPDVENDORNAME4                  0x104E
-#define HDMI_FC_SPDVENDORNAME5                  0x104F
-#define HDMI_FC_SPDVENDORNAME6                  0x1050
-#define HDMI_FC_SPDVENDORNAME7                  0x1051
-#define HDMI_FC_SDPPRODUCTNAME0                 0x1052
-#define HDMI_FC_SDPPRODUCTNAME1                 0x1053
-#define HDMI_FC_SDPPRODUCTNAME2                 0x1054
-#define HDMI_FC_SDPPRODUCTNAME3                 0x1055
-#define HDMI_FC_SDPPRODUCTNAME4                 0x1056
-#define HDMI_FC_SDPPRODUCTNAME5                 0x1057
-#define HDMI_FC_SDPPRODUCTNAME6                 0x1058
-#define HDMI_FC_SDPPRODUCTNAME7                 0x1059
-#define HDMI_FC_SDPPRODUCTNAME8                 0x105A
-#define HDMI_FC_SDPPRODUCTNAME9                 0x105B
-#define HDMI_FC_SDPPRODUCTNAME10                0x105C
-#define HDMI_FC_SDPPRODUCTNAME11                0x105D
-#define HDMI_FC_SDPPRODUCTNAME12                0x105E
-#define HDMI_FC_SDPPRODUCTNAME13                0x105F
-#define HDMI_FC_SDPPRODUCTNAME14                0x1060
-#define HDMI_FC_SPDPRODUCTNAME15                0x1061
-#define HDMI_FC_SPDDEVICEINF                    0x1062
-#define HDMI_FC_AUDSCONF                        0x1063
-#define HDMI_FC_AUDSSTAT                        0x1064
-#define HDMI_FC_AUDSV                           0x1065
-#define HDMI_FC_AUDSU                           0x1066
-#define HDMI_FC_AUDSCHNL0                       0x1067
-#define HDMI_FC_AUDSCHNL1                       0x1068
-#define HDMI_FC_AUDSCHNL2                       0x1069
-#define HDMI_FC_AUDSCHNL3                       0x106A
-#define HDMI_FC_AUDSCHNL4                       0x106B
-#define HDMI_FC_AUDSCHNL5                       0x106C
-#define HDMI_FC_AUDSCHNL6                       0x106D
-#define HDMI_FC_AUDSCHNL7                       0x106E
-#define HDMI_FC_AUDSCHNL8                       0x106F
-#define HDMI_FC_DATACH0FILL                     0x1070
-#define HDMI_FC_DATACH1FILL                     0x1071
-#define HDMI_FC_DATACH2FILL                     0x1072
-#define HDMI_FC_CTRLQHIGH                       0x1073
-#define HDMI_FC_CTRLQLOW                        0x1074
-#define HDMI_FC_ACP0                            0x1075
-#define HDMI_FC_ACP28                           0x1076
-#define HDMI_FC_ACP27                           0x1077
-#define HDMI_FC_ACP26                           0x1078
-#define HDMI_FC_ACP25                           0x1079
-#define HDMI_FC_ACP24                           0x107A
-#define HDMI_FC_ACP23                           0x107B
-#define HDMI_FC_ACP22                           0x107C
-#define HDMI_FC_ACP21                           0x107D
-#define HDMI_FC_ACP20                           0x107E
-#define HDMI_FC_ACP19                           0x107F
-#define HDMI_FC_ACP18                           0x1080
-#define HDMI_FC_ACP17                           0x1081
-#define HDMI_FC_ACP16                           0x1082
-#define HDMI_FC_ACP15                           0x1083
-#define HDMI_FC_ACP14                           0x1084
-#define HDMI_FC_ACP13                           0x1085
-#define HDMI_FC_ACP12                           0x1086
-#define HDMI_FC_ACP11                           0x1087
-#define HDMI_FC_ACP10                           0x1088
-#define HDMI_FC_ACP9                            0x1089
-#define HDMI_FC_ACP8                            0x108A
-#define HDMI_FC_ACP7                            0x108B
-#define HDMI_FC_ACP6                            0x108C
-#define HDMI_FC_ACP5                            0x108D
-#define HDMI_FC_ACP4                            0x108E
-#define HDMI_FC_ACP3                            0x108F
-#define HDMI_FC_ACP2                            0x1090
-#define HDMI_FC_ACP1                            0x1091
-#define HDMI_FC_ISCR1_0                         0x1092
-#define HDMI_FC_ISCR1_16                        0x1093
-#define HDMI_FC_ISCR1_15                        0x1094
-#define HDMI_FC_ISCR1_14                        0x1095
-#define HDMI_FC_ISCR1_13                        0x1096
-#define HDMI_FC_ISCR1_12                        0x1097
-#define HDMI_FC_ISCR1_11                        0x1098
-#define HDMI_FC_ISCR1_10                        0x1099
-#define HDMI_FC_ISCR1_9                         0x109A
-#define HDMI_FC_ISCR1_8                         0x109B
-#define HDMI_FC_ISCR1_7                         0x109C
-#define HDMI_FC_ISCR1_6                         0x109D
-#define HDMI_FC_ISCR1_5                         0x109E
-#define HDMI_FC_ISCR1_4                         0x109F
-#define HDMI_FC_ISCR1_3                         0x10A0
-#define HDMI_FC_ISCR1_2                         0x10A1
-#define HDMI_FC_ISCR1_1                         0x10A2
-#define HDMI_FC_ISCR2_15                        0x10A3
-#define HDMI_FC_ISCR2_14                        0x10A4
-#define HDMI_FC_ISCR2_13                        0x10A5
-#define HDMI_FC_ISCR2_12                        0x10A6
-#define HDMI_FC_ISCR2_11                        0x10A7
-#define HDMI_FC_ISCR2_10                        0x10A8
-#define HDMI_FC_ISCR2_9                         0x10A9
-#define HDMI_FC_ISCR2_8                         0x10AA
-#define HDMI_FC_ISCR2_7                         0x10AB
-#define HDMI_FC_ISCR2_6                         0x10AC
-#define HDMI_FC_ISCR2_5                         0x10AD
-#define HDMI_FC_ISCR2_4                         0x10AE
-#define HDMI_FC_ISCR2_3                         0x10AF
-#define HDMI_FC_ISCR2_2                         0x10B0
-#define HDMI_FC_ISCR2_1                         0x10B1
-#define HDMI_FC_ISCR2_0                         0x10B2
-#define HDMI_FC_DATAUTO0                        0x10B3
-#define HDMI_FC_DATAUTO1                        0x10B4
-#define HDMI_FC_DATAUTO2                        0x10B5
-#define HDMI_FC_DATMAN                          0x10B6
-#define HDMI_FC_DATAUTO3                        0x10B7
-#define HDMI_FC_RDRB0                           0x10B8
-#define HDMI_FC_RDRB1                           0x10B9
-#define HDMI_FC_RDRB2                           0x10BA
-#define HDMI_FC_RDRB3                           0x10BB
-#define HDMI_FC_RDRB4                           0x10BC
-#define HDMI_FC_RDRB5                           0x10BD
-#define HDMI_FC_RDRB6                           0x10BE
-#define HDMI_FC_RDRB7                           0x10BF
-#define HDMI_FC_STAT0                           0x10D0
-#define HDMI_FC_INT0                            0x10D1
-#define HDMI_FC_MASK0                           0x10D2
-#define HDMI_FC_POL0                            0x10D3
-#define HDMI_FC_STAT1                           0x10D4
-#define HDMI_FC_INT1                            0x10D5
-#define HDMI_FC_MASK1                           0x10D6
-#define HDMI_FC_POL1                            0x10D7
-#define HDMI_FC_STAT2                           0x10D8
-#define HDMI_FC_INT2                            0x10D9
-#define HDMI_FC_MASK2                           0x10DA
-#define HDMI_FC_POL2                            0x10DB
-#define HDMI_FC_PRCONF                          0x10E0
-#define HDMI_FC_SCRAMBLER_CTRL                  0x10E1
-
-#define HDMI_FC_GMD_STAT                        0x1100
-#define HDMI_FC_GMD_EN                          0x1101
-#define HDMI_FC_GMD_UP                          0x1102
-#define HDMI_FC_GMD_CONF                        0x1103
-#define HDMI_FC_GMD_HB                          0x1104
-#define HDMI_FC_GMD_PB0                         0x1105
-#define HDMI_FC_GMD_PB1                         0x1106
-#define HDMI_FC_GMD_PB2                         0x1107
-#define HDMI_FC_GMD_PB3                         0x1108
-#define HDMI_FC_GMD_PB4                         0x1109
-#define HDMI_FC_GMD_PB5                         0x110A
-#define HDMI_FC_GMD_PB6                         0x110B
-#define HDMI_FC_GMD_PB7                         0x110C
-#define HDMI_FC_GMD_PB8                         0x110D
-#define HDMI_FC_GMD_PB9                         0x110E
-#define HDMI_FC_GMD_PB10                        0x110F
-#define HDMI_FC_GMD_PB11                        0x1110
-#define HDMI_FC_GMD_PB12                        0x1111
-#define HDMI_FC_GMD_PB13                        0x1112
-#define HDMI_FC_GMD_PB14                        0x1113
-#define HDMI_FC_GMD_PB15                        0x1114
-#define HDMI_FC_GMD_PB16                        0x1115
-#define HDMI_FC_GMD_PB17                        0x1116
-#define HDMI_FC_GMD_PB18                        0x1117
-#define HDMI_FC_GMD_PB19                        0x1118
-#define HDMI_FC_GMD_PB20                        0x1119
-#define HDMI_FC_GMD_PB21                        0x111A
-#define HDMI_FC_GMD_PB22                        0x111B
-#define HDMI_FC_GMD_PB23                        0x111C
-#define HDMI_FC_GMD_PB24                        0x111D
-#define HDMI_FC_GMD_PB25                        0x111E
-#define HDMI_FC_GMD_PB26                        0x111F
-#define HDMI_FC_GMD_PB27                        0x1120
-
-#define HDMI_FC_DBGFORCE                        0x1200
-#define HDMI_FC_DBGAUD0CH0                      0x1201
-#define HDMI_FC_DBGAUD1CH0                      0x1202
-#define HDMI_FC_DBGAUD2CH0                      0x1203
-#define HDMI_FC_DBGAUD0CH1                      0x1204
-#define HDMI_FC_DBGAUD1CH1                      0x1205
-#define HDMI_FC_DBGAUD2CH1                      0x1206
-#define HDMI_FC_DBGAUD0CH2                      0x1207
-#define HDMI_FC_DBGAUD1CH2                      0x1208
-#define HDMI_FC_DBGAUD2CH2                      0x1209
-#define HDMI_FC_DBGAUD0CH3                      0x120A
-#define HDMI_FC_DBGAUD1CH3                      0x120B
-#define HDMI_FC_DBGAUD2CH3                      0x120C
-#define HDMI_FC_DBGAUD0CH4                      0x120D
-#define HDMI_FC_DBGAUD1CH4                      0x120E
-#define HDMI_FC_DBGAUD2CH4                      0x120F
-#define HDMI_FC_DBGAUD0CH5                      0x1210
-#define HDMI_FC_DBGAUD1CH5                      0x1211
-#define HDMI_FC_DBGAUD2CH5                      0x1212
-#define HDMI_FC_DBGAUD0CH6                      0x1213
-#define HDMI_FC_DBGAUD1CH6                      0x1214
-#define HDMI_FC_DBGAUD2CH6                      0x1215
-#define HDMI_FC_DBGAUD0CH7                      0x1216
-#define HDMI_FC_DBGAUD1CH7                      0x1217
-#define HDMI_FC_DBGAUD2CH7                      0x1218
-#define HDMI_FC_DBGTMDS0                        0x1219
-#define HDMI_FC_DBGTMDS1                        0x121A
-#define HDMI_FC_DBGTMDS2                        0x121B
-
-/* HDMI Source PHY Registers */
-#define HDMI_PHY_CONF0                          0x3000
-#define HDMI_PHY_TST0                           0x3001
-#define HDMI_PHY_TST1                           0x3002
-#define HDMI_PHY_TST2                           0x3003
-#define HDMI_PHY_STAT0                          0x3004
-#define HDMI_PHY_INT0                           0x3005
-#define HDMI_PHY_MASK0                          0x3006
-#define HDMI_PHY_POL0                           0x3007
-
-/* HDMI Master PHY Registers */
-#define HDMI_PHY_I2CM_SLAVE_ADDR                0x3020
-#define HDMI_PHY_I2CM_ADDRESS_ADDR              0x3021
-#define HDMI_PHY_I2CM_DATAO_1_ADDR              0x3022
-#define HDMI_PHY_I2CM_DATAO_0_ADDR              0x3023
-#define HDMI_PHY_I2CM_DATAI_1_ADDR              0x3024
-#define HDMI_PHY_I2CM_DATAI_0_ADDR              0x3025
-#define HDMI_PHY_I2CM_OPERATION_ADDR            0x3026
-#define HDMI_PHY_I2CM_INT_ADDR                  0x3027
-#define HDMI_PHY_I2CM_CTLINT_ADDR               0x3028
-#define HDMI_PHY_I2CM_DIV_ADDR                  0x3029
-#define HDMI_PHY_I2CM_SOFTRSTZ_ADDR             0x302a
-#define HDMI_PHY_I2CM_SS_SCL_HCNT_1_ADDR        0x302b
-#define HDMI_PHY_I2CM_SS_SCL_HCNT_0_ADDR        0x302c
-#define HDMI_PHY_I2CM_SS_SCL_LCNT_1_ADDR        0x302d
-#define HDMI_PHY_I2CM_SS_SCL_LCNT_0_ADDR        0x302e
-#define HDMI_PHY_I2CM_FS_SCL_HCNT_1_ADDR        0x302f
-#define HDMI_PHY_I2CM_FS_SCL_HCNT_0_ADDR        0x3030
-#define HDMI_PHY_I2CM_FS_SCL_LCNT_1_ADDR        0x3031
-#define HDMI_PHY_I2CM_FS_SCL_LCNT_0_ADDR        0x3032
-
-/* Audio Sampler Registers */
-#define HDMI_AUD_CONF0                          0x3100
-#define HDMI_AUD_CONF1                          0x3101
-#define HDMI_AUD_INT                            0x3102
-#define HDMI_AUD_CONF2                          0x3103
-#define HDMI_AUD_N1                             0x3200
-#define HDMI_AUD_N2                             0x3201
-#define HDMI_AUD_N3                             0x3202
-#define HDMI_AUD_CTS1                           0x3203
-#define HDMI_AUD_CTS2                           0x3204
-#define HDMI_AUD_CTS3                           0x3205
-#define HDMI_AUD_INPUTCLKFS                     0x3206
-#define HDMI_AUD_SPDIFINT			0x3302
-#define HDMI_AUD_CONF0_HBR                      0x3400
-#define HDMI_AUD_HBR_STATUS                     0x3401
-#define HDMI_AUD_HBR_INT                        0x3402
-#define HDMI_AUD_HBR_POL                        0x3403
-#define HDMI_AUD_HBR_MASK                       0x3404
-
-/*
- * Generic Parallel Audio Interface Registers
- * Not used as GPAUD interface is not enabled in hw
- */
-#define HDMI_GP_CONF0                           0x3500
-#define HDMI_GP_CONF1                           0x3501
-#define HDMI_GP_CONF2                           0x3502
-#define HDMI_GP_STAT                            0x3503
-#define HDMI_GP_INT                             0x3504
-#define HDMI_GP_MASK                            0x3505
-#define HDMI_GP_POL                             0x3506
-
-/* Audio DMA Registers */
-#define HDMI_AHB_DMA_CONF0                      0x3600
-#define HDMI_AHB_DMA_START                      0x3601
-#define HDMI_AHB_DMA_STOP                       0x3602
-#define HDMI_AHB_DMA_THRSLD                     0x3603
-#define HDMI_AHB_DMA_STRADDR0                   0x3604
-#define HDMI_AHB_DMA_STRADDR1                   0x3605
-#define HDMI_AHB_DMA_STRADDR2                   0x3606
-#define HDMI_AHB_DMA_STRADDR3                   0x3607
-#define HDMI_AHB_DMA_STPADDR0                   0x3608
-#define HDMI_AHB_DMA_STPADDR1                   0x3609
-#define HDMI_AHB_DMA_STPADDR2                   0x360a
-#define HDMI_AHB_DMA_STPADDR3                   0x360b
-#define HDMI_AHB_DMA_BSTADDR0                   0x360c
-#define HDMI_AHB_DMA_BSTADDR1                   0x360d
-#define HDMI_AHB_DMA_BSTADDR2                   0x360e
-#define HDMI_AHB_DMA_BSTADDR3                   0x360f
-#define HDMI_AHB_DMA_MBLENGTH0                  0x3610
-#define HDMI_AHB_DMA_MBLENGTH1                  0x3611
-#define HDMI_AHB_DMA_STAT                       0x3612
-#define HDMI_AHB_DMA_INT                        0x3613
-#define HDMI_AHB_DMA_MASK                       0x3614
-#define HDMI_AHB_DMA_POL                        0x3615
-#define HDMI_AHB_DMA_CONF1                      0x3616
-#define HDMI_AHB_DMA_BUFFSTAT                   0x3617
-#define HDMI_AHB_DMA_BUFFINT                    0x3618
-#define HDMI_AHB_DMA_BUFFMASK                   0x3619
-#define HDMI_AHB_DMA_BUFFPOL                    0x361a
-
-/* Main Controller Registers */
-#define HDMI_MC_SFRDIV                          0x4000
-#define HDMI_MC_CLKDIS                          0x4001
-#define HDMI_MC_SWRSTZ                          0x4002
-#define HDMI_MC_OPCTRL                          0x4003
-#define HDMI_MC_FLOWCTRL                        0x4004
-#define HDMI_MC_PHYRSTZ                         0x4005
-#define HDMI_MC_LOCKONCLOCK                     0x4006
-#define HDMI_MC_HEACPHY_RST                     0x4007
-
-/* Color Space  Converter Registers */
-#define HDMI_CSC_CFG                            0x4100
-#define HDMI_CSC_SCALE                          0x4101
-#define HDMI_CSC_COEF_A1_MSB                    0x4102
-#define HDMI_CSC_COEF_A1_LSB                    0x4103
-#define HDMI_CSC_COEF_A2_MSB                    0x4104
-#define HDMI_CSC_COEF_A2_LSB                    0x4105
-#define HDMI_CSC_COEF_A3_MSB                    0x4106
-#define HDMI_CSC_COEF_A3_LSB                    0x4107
-#define HDMI_CSC_COEF_A4_MSB                    0x4108
-#define HDMI_CSC_COEF_A4_LSB                    0x4109
-#define HDMI_CSC_COEF_B1_MSB                    0x410A
-#define HDMI_CSC_COEF_B1_LSB                    0x410B
-#define HDMI_CSC_COEF_B2_MSB                    0x410C
-#define HDMI_CSC_COEF_B2_LSB                    0x410D
-#define HDMI_CSC_COEF_B3_MSB                    0x410E
-#define HDMI_CSC_COEF_B3_LSB                    0x410F
-#define HDMI_CSC_COEF_B4_MSB                    0x4110
-#define HDMI_CSC_COEF_B4_LSB                    0x4111
-#define HDMI_CSC_COEF_C1_MSB                    0x4112
-#define HDMI_CSC_COEF_C1_LSB                    0x4113
-#define HDMI_CSC_COEF_C2_MSB                    0x4114
-#define HDMI_CSC_COEF_C2_LSB                    0x4115
-#define HDMI_CSC_COEF_C3_MSB                    0x4116
-#define HDMI_CSC_COEF_C3_LSB                    0x4117
-#define HDMI_CSC_COEF_C4_MSB                    0x4118
-#define HDMI_CSC_COEF_C4_LSB                    0x4119
-
-/* HDCP Encryption Engine Registers */
-#define HDMI_A_HDCPCFG0                         0x5000
-#define HDMI_A_HDCPCFG1                         0x5001
-#define HDMI_A_HDCPOBS0                         0x5002
-#define HDMI_A_HDCPOBS1                         0x5003
-#define HDMI_A_HDCPOBS2                         0x5004
-#define HDMI_A_HDCPOBS3                         0x5005
-#define HDMI_A_APIINTCLR                        0x5006
-#define HDMI_A_APIINTSTAT                       0x5007
-#define HDMI_A_APIINTMSK                        0x5008
-#define HDMI_A_VIDPOLCFG                        0x5009
-#define HDMI_A_OESSWCFG                         0x500A
-#define HDMI_A_TIMER1SETUP0                     0x500B
-#define HDMI_A_TIMER1SETUP1                     0x500C
-#define HDMI_A_TIMER2SETUP0                     0x500D
-#define HDMI_A_TIMER2SETUP1                     0x500E
-#define HDMI_A_100MSCFG                         0x500F
-#define HDMI_A_2SCFG0                           0x5010
-#define HDMI_A_2SCFG1                           0x5011
-#define HDMI_A_5SCFG0                           0x5012
-#define HDMI_A_5SCFG1                           0x5013
-#define HDMI_A_SRMVERLSB                        0x5014
-#define HDMI_A_SRMVERMSB                        0x5015
-#define HDMI_A_SRMCTRL                          0x5016
-#define HDMI_A_SFRSETUP                         0x5017
-#define HDMI_A_I2CHSETUP                        0x5018
-#define HDMI_A_INTSETUP                         0x5019
-#define HDMI_A_PRESETUP                         0x501A
-#define HDMI_A_SRM_BASE                         0x5020
-
-/* I2C Master Registers (E-DDC) */
-#define HDMI_I2CM_SLAVE                         0x7E00
-#define HDMI_I2CM_ADDRESS                       0x7E01
-#define HDMI_I2CM_DATAO                         0x7E02
-#define HDMI_I2CM_DATAI                         0x7E03
-#define HDMI_I2CM_OPERATION                     0x7E04
-#define HDMI_I2CM_INT                           0x7E05
-#define HDMI_I2CM_CTLINT                        0x7E06
-#define HDMI_I2CM_DIV                           0x7E07
-#define HDMI_I2CM_SEGADDR                       0x7E08
-#define HDMI_I2CM_SOFTRSTZ                      0x7E09
-#define HDMI_I2CM_SEGPTR                        0x7E0A
-#define HDMI_I2CM_SS_SCL_HCNT_1_ADDR            0x7E0B
-#define HDMI_I2CM_SS_SCL_HCNT_0_ADDR            0x7E0C
-#define HDMI_I2CM_SS_SCL_LCNT_1_ADDR            0x7E0D
-#define HDMI_I2CM_SS_SCL_LCNT_0_ADDR            0x7E0E
-#define HDMI_I2CM_FS_SCL_HCNT_1_ADDR            0x7E0F
-#define HDMI_I2CM_FS_SCL_HCNT_0_ADDR            0x7E10
-#define HDMI_I2CM_FS_SCL_LCNT_1_ADDR            0x7E11
-#define HDMI_I2CM_FS_SCL_LCNT_0_ADDR            0x7E12
-
-enum {
-/* PRODUCT_ID0 field values */
-	HDMI_PRODUCT_ID0_HDMI_TX = 0xa0,
-
-/* PRODUCT_ID1 field values */
-	HDMI_PRODUCT_ID1_HDCP = 0xc0,
-	HDMI_PRODUCT_ID1_HDMI_RX = 0x02,
-	HDMI_PRODUCT_ID1_HDMI_TX = 0x01,
-
-/* CONFIG0_ID field values */
-	HDMI_CONFIG0_I2S = 0x10,
-	HDMI_CONFIG0_CEC = 0x02,
-
-/* CONFIG1_ID field values */
-	HDMI_CONFIG1_AHB = 0x01,
-
-/* CONFIG3_ID field values */
-	HDMI_CONFIG3_AHBAUDDMA = 0x02,
-	HDMI_CONFIG3_GPAUD = 0x01,
-
-/* IH_FC_INT2 field values */
-	HDMI_IH_FC_INT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* IH_FC_STAT2 field values */
-	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* IH_PHY_STAT0 field values */
-	HDMI_IH_PHY_STAT0_RX_SENSE3 = 0x20,
-	HDMI_IH_PHY_STAT0_RX_SENSE2 = 0x10,
-	HDMI_IH_PHY_STAT0_RX_SENSE1 = 0x8,
-	HDMI_IH_PHY_STAT0_RX_SENSE0 = 0x4,
-	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 0x2,
-	HDMI_IH_PHY_STAT0_HPD = 0x1,
-
-/* IH_I2CM_STAT0 and IH_MUTE_I2CM_STAT0 field values */
-	HDMI_IH_I2CM_STAT0_DONE = 0x2,
-	HDMI_IH_I2CM_STAT0_ERROR = 0x1,
-
-/* IH_MUTE_I2CMPHY_STAT0 field values */
-	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 0x2,
-	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 0x1,
-
-/* IH_AHBDMAAUD_STAT0 field values */
-	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 0x20,
-	HDMI_IH_AHBDMAAUD_STAT0_LOST = 0x10,
-	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 0x08,
-	HDMI_IH_AHBDMAAUD_STAT0_DONE = 0x04,
-	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
-	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
-
-/* IH_MUTE_FC_STAT2 field values */
-	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* IH_MUTE_AHBDMAAUD_STAT0 field values */
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 0x20,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 0x10,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 0x08,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 0x04,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 0x02,
-	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 0x01,
-
-/* IH_MUTE field values */
-	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 0x2,
-	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 0x1,
-
-/* TX_INVID0 field values */
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 0x80,
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 0x80,
-	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0x00,
-	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 0x1F,
-	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
-
-/* TX_INSTUFFING field values */
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 0x4,
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 0x4,
-	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0x0,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 0x2,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 0x2,
-	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0x0,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 0x1,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 0x1,
-	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0x0,
-
-/* VP_PR_CD field values */
-	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 0xF0,
-	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
-	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 0x0F,
-	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
-
-/* VP_STUFF field values */
-	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 0x20,
-	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
-	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 0x10,
-	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
-	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 0x8,
-	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
-	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 0x4,
-	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 0x4,
-	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0x0,
-	HDMI_VP_STUFF_PP_STUFFING_MASK = 0x2,
-	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 0x2,
-	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0x0,
-	HDMI_VP_STUFF_PR_STUFFING_MASK = 0x1,
-	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 0x1,
-	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0x0,
-
-/* VP_CONF field values */
-	HDMI_VP_CONF_BYPASS_EN_MASK = 0x40,
-	HDMI_VP_CONF_BYPASS_EN_ENABLE = 0x40,
-	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_PP_EN_ENMASK = 0x20,
-	HDMI_VP_CONF_PP_EN_ENABLE = 0x20,
-	HDMI_VP_CONF_PP_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_PR_EN_MASK = 0x10,
-	HDMI_VP_CONF_PR_EN_ENABLE = 0x10,
-	HDMI_VP_CONF_PR_EN_DISABLE = 0x00,
-	HDMI_VP_CONF_YCC422_EN_MASK = 0x8,
-	HDMI_VP_CONF_YCC422_EN_ENABLE = 0x8,
-	HDMI_VP_CONF_YCC422_EN_DISABLE = 0x0,
-	HDMI_VP_CONF_BYPASS_SELECT_MASK = 0x4,
-	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 0x4,
-	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0x0,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 0x3,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 0x3,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 0x1,
-	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0x0,
-
-/* VP_REMAP field values */
-	HDMI_VP_REMAP_MASK = 0x3,
-	HDMI_VP_REMAP_YCC422_24bit = 0x2,
-	HDMI_VP_REMAP_YCC422_20bit = 0x1,
-	HDMI_VP_REMAP_YCC422_16bit = 0x0,
-
-/* FC_INVIDCONF field values */
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 0x80,
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 0x80,
-	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0x00,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 0x40,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 0x40,
-	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 0x20,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 0x20,
-	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 0x10,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 0x10,
-	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0x00,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 0x8,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 0x8,
-	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0x0,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 0x2,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 0x2,
-	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0x0,
-	HDMI_FC_INVIDCONF_IN_I_P_MASK = 0x1,
-	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 0x1,
-	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0x0,
-
-/* FC_AUDICONF0 field values */
-	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
-	HDMI_FC_AUDICONF0_CC_MASK = 0x70,
-	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
-	HDMI_FC_AUDICONF0_CT_MASK = 0xF,
-
-/* FC_AUDICONF1 field values */
-	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
-	HDMI_FC_AUDICONF1_SS_MASK = 0x18,
-	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
-	HDMI_FC_AUDICONF1_SF_MASK = 0x7,
-
-/* FC_AUDICONF3 field values */
-	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
-	HDMI_FC_AUDICONF3_LFEPBL_MASK = 0x60,
-	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
-	HDMI_FC_AUDICONF3_DM_INH_MASK = 0x10,
-	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
-	HDMI_FC_AUDICONF3_LSV_MASK = 0xF,
-
-/* FC_AUDSCHNLS0 field values */
-	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 0x30,
-	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 0x01,
-
-/* FC_AUDSCHNLS3-6 field values */
-	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 0xf0,
-
-	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 0xf0,
-
-/* HDMI_FC_AUDSCHNLS7 field values */
-	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 0x30,
-
-/* HDMI_FC_AUDSCHNLS8 field values */
-	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 0xf0,
-	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
-	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 0x0f,
-	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
-
-/* FC_AUDSCONF field values */
-	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 0xF0,
-	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 0x1,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 0x1,
-	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0x0,
-
-/* FC_STAT2 field values */
-	HDMI_FC_STAT2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* FC_INT2 field values */
-	HDMI_FC_INT2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* FC_MASK2 field values */
-	HDMI_FC_MASK2_OVERFLOW_MASK = 0x03,
-	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 0x02,
-	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 0x01,
-
-/* FC_PRCONF field values */
-	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 0xF0,
-	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
-	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 0x0F,
-	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
-
-/* FC_AVICONF0-FC_AVICONF3 field values */
-	HDMI_FC_AVICONF0_PIX_FMT_MASK = 0x03,
-	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0x00,
-	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 0x01,
-	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 0x02,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 0x40,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 0x40,
-	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0x00,
-	HDMI_FC_AVICONF0_BAR_DATA_MASK = 0x0C,
-	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0x00,
-	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 0x04,
-	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 0x08,
-	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 0x0C,
-	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 0x30,
-	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 0x10,
-	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 0x20,
-	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0x00,
-
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 0x0F,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 0x08,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 0x09,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 0x0A,
-	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 0x0B,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 0x30,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0x00,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 0x10,
-	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 0x20,
-	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 0xC0,
-	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0x00,
-	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 0x40,
-	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 0x80,
-	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 0xC0,
-
-	HDMI_FC_AVICONF2_SCALING_MASK = 0x03,
-	HDMI_FC_AVICONF2_SCALING_NONE = 0x00,
-	HDMI_FC_AVICONF2_SCALING_HORIZ = 0x01,
-	HDMI_FC_AVICONF2_SCALING_VERT = 0x02,
-	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 0x03,
-	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 0x0C,
-	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0x00,
-	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 0x04,
-	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 0x08,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 0x70,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0x00,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 0x10,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 0x20,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 0x30,
-	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 0x40,
-	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 0x80,
-	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0x00,
-	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 0x80,
-
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 0x03,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0x00,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 0x01,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 0x02,
-	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 0x03,
-	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 0x0C,
-	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0x00,
-	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 0x04,
-
-/* FC_DBGFORCE field values */
-	HDMI_FC_DBGFORCE_FORCEAUDIO = 0x10,
-	HDMI_FC_DBGFORCE_FORCEVIDEO = 0x1,
-
-/* FC_DATAUTO0 field values */
-	HDMI_FC_DATAUTO0_VSD_MASK = 0x08,
-	HDMI_FC_DATAUTO0_VSD_OFFSET = 3,
-
-/* PHY_CONF0 field values */
-	HDMI_PHY_CONF0_PDZ_MASK = 0x80,
-	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
-	HDMI_PHY_CONF0_ENTMDS_MASK = 0x40,
-	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
-	HDMI_PHY_CONF0_SVSRET_MASK = 0x20,
-	HDMI_PHY_CONF0_SVSRET_OFFSET = 5,
-	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 0x10,
-	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
-	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 0x8,
-	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
-	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 0x4,
-	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
-	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 0x2,
-	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
-	HDMI_PHY_CONF0_SELDIPIF_MASK = 0x1,
-	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
-
-/* PHY_TST0 field values */
-	HDMI_PHY_TST0_TSTCLR_MASK = 0x20,
-	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
-	HDMI_PHY_TST0_TSTEN_MASK = 0x10,
-	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
-	HDMI_PHY_TST0_TSTCLK_MASK = 0x1,
-	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
-
-/* PHY_STAT0 field values */
-	HDMI_PHY_RX_SENSE3 = 0x80,
-	HDMI_PHY_RX_SENSE2 = 0x40,
-	HDMI_PHY_RX_SENSE1 = 0x20,
-	HDMI_PHY_RX_SENSE0 = 0x10,
-	HDMI_PHY_HPD = 0x02,
-	HDMI_PHY_TX_PHY_LOCK = 0x01,
-
-/* PHY_I2CM_SLAVE_ADDR field values */
-	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 0x69,
-	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 0x49,
-
-/* PHY_I2CM_OPERATION_ADDR field values */
-	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 0x10,
-	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 0x1,
-
-/* HDMI_PHY_I2CM_INT_ADDR */
-	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 0x08,
-	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 0x04,
-
-/* HDMI_PHY_I2CM_CTLINT_ADDR */
-	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 0x80,
-	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 0x40,
-	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 0x08,
-	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 0x04,
-
-/* AUD_CONF0 field values */
-	HDMI_AUD_CONF0_SW_RESET = 0x80,
-	HDMI_AUD_CONF0_I2S_SELECT = 0x20,
-	HDMI_AUD_CONF0_I2S_EN3 = 0x08,
-	HDMI_AUD_CONF0_I2S_EN2 = 0x04,
-	HDMI_AUD_CONF0_I2S_EN1 = 0x02,
-	HDMI_AUD_CONF0_I2S_EN0 = 0x01,
-
-/* AUD_CONF1 field values */
-	HDMI_AUD_CONF1_MODE_I2S = 0x00,
-	HDMI_AUD_CONF1_MODE_RIGHT_J = 0x20,
-	HDMI_AUD_CONF1_MODE_LEFT_J = 0x40,
-	HDMI_AUD_CONF1_MODE_BURST_1 = 0x60,
-	HDMI_AUD_CONF1_MODE_BURST_2 = 0x80,
-	HDMI_AUD_CONF1_WIDTH_16 = 0x10,
-	HDMI_AUD_CONF1_WIDTH_24 = 0x18,
-
-/* AUD_CTS3 field values */
-	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
-	HDMI_AUD_CTS3_N_SHIFT_MASK = 0xe0,
-	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
-	HDMI_AUD_CTS3_N_SHIFT_16 = 0x20,
-	HDMI_AUD_CTS3_N_SHIFT_32 = 0x40,
-	HDMI_AUD_CTS3_N_SHIFT_64 = 0x60,
-	HDMI_AUD_CTS3_N_SHIFT_128 = 0x80,
-	HDMI_AUD_CTS3_N_SHIFT_256 = 0xa0,
-	/* note that the CTS3 MANUAL bit has been removed
-	   from our part. Can't set it, will read as 0. */
-	HDMI_AUD_CTS3_CTS_MANUAL = 0x10,
-	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 0x0f,
-
-/* HDMI_AUD_INPUTCLKFS field values */
-	HDMI_AUD_INPUTCLKFS_128FS = 0,
-	HDMI_AUD_INPUTCLKFS_256FS = 1,
-	HDMI_AUD_INPUTCLKFS_512FS = 2,
-	HDMI_AUD_INPUTCLKFS_64FS = 4,
-
-/* AHB_DMA_CONF0 field values */
-	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
-	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 0x80,
-	HDMI_AHB_DMA_CONF0_HBR = 0x10,
-	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
-	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 0x08,
-	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
-	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 0x06,
-	HDMI_AHB_DMA_CONF0_INCR4 = 0x0,
-	HDMI_AHB_DMA_CONF0_INCR8 = 0x2,
-	HDMI_AHB_DMA_CONF0_INCR16 = 0x4,
-	HDMI_AHB_DMA_CONF0_BURST_MODE = 0x1,
-
-/* HDMI_AHB_DMA_START field values */
-	HDMI_AHB_DMA_START_START_OFFSET = 0,
-	HDMI_AHB_DMA_START_START_MASK = 0x01,
-
-/* HDMI_AHB_DMA_STOP field values */
-	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
-	HDMI_AHB_DMA_STOP_STOP_MASK = 0x01,
-
-/* AHB_DMA_STAT, AHB_DMA_INT, AHB_DMA_MASK, AHB_DMA_POL field values */
-	HDMI_AHB_DMA_DONE = 0x80,
-	HDMI_AHB_DMA_RETRY_SPLIT = 0x40,
-	HDMI_AHB_DMA_LOSTOWNERSHIP = 0x20,
-	HDMI_AHB_DMA_ERROR = 0x10,
-	HDMI_AHB_DMA_FIFO_THREMPTY = 0x04,
-	HDMI_AHB_DMA_FIFO_FULL = 0x02,
-	HDMI_AHB_DMA_FIFO_EMPTY = 0x01,
-
-/* AHB_DMA_BUFFSTAT, AHB_DMA_BUFFINT,AHB_DMA_BUFFMASK,AHB_DMA_BUFFPOL values */
-	HDMI_AHB_DMA_BUFFSTAT_FULL = 0x02,
-	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 0x01,
-
-/* MC_CLKDIS field values */
-	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 0x40,
-	HDMI_MC_CLKDIS_CECCLK_DISABLE = 0x20,
-	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 0x10,
-	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 0x8,
-	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 0x4,
-	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 0x2,
-	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 0x1,
-
-/* MC_SWRSTZ field values */
-	HDMI_MC_SWRSTZ_I2SSWRST_REQ = 0x08,
-	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 0x02,
-
-/* MC_FLOWCTRL field values */
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 0x1,
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 0x1,
-	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0x0,
-
-/* MC_PHYRSTZ field values */
-	HDMI_MC_PHYRSTZ_PHYRSTZ = 0x01,
-
-/* MC_HEACPHY_RST field values */
-	HDMI_MC_HEACPHY_RST_ASSERT = 0x1,
-	HDMI_MC_HEACPHY_RST_DEASSERT = 0x0,
-
-/* CSC_CFG field values */
-	HDMI_CSC_CFG_INTMODE_MASK = 0x30,
-	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
-	HDMI_CSC_CFG_INTMODE_DISABLE = 0x00,
-	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 0x10,
-	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 0x20,
-	HDMI_CSC_CFG_DECMODE_MASK = 0x3,
-	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
-	HDMI_CSC_CFG_DECMODE_DISABLE = 0x0,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 0x1,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 0x2,
-	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 0x3,
-
-/* CSC_SCALE field values */
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 0xF0,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0x00,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 0x50,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 0x60,
-	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 0x70,
-	HDMI_CSC_SCALE_CSCSCALE_MASK = 0x03,
-
-/* A_HDCPCFG0 field values */
-	HDMI_A_HDCPCFG0_ELVENA_MASK = 0x80,
-	HDMI_A_HDCPCFG0_ELVENA_ENABLE = 0x80,
-	HDMI_A_HDCPCFG0_ELVENA_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_MASK = 0x40,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_ENABLE = 0x40,
-	HDMI_A_HDCPCFG0_I2CFASTMODE_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_MASK = 0x20,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_ENABLE = 0x20,
-	HDMI_A_HDCPCFG0_BYPENCRYPTION_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_MASK = 0x10,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_ENABLE = 0x10,
-	HDMI_A_HDCPCFG0_SYNCRICHECK_DISABLE = 0x00,
-	HDMI_A_HDCPCFG0_AVMUTE_MASK = 0x8,
-	HDMI_A_HDCPCFG0_AVMUTE_ENABLE = 0x8,
-	HDMI_A_HDCPCFG0_AVMUTE_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_RXDETECT_MASK = 0x4,
-	HDMI_A_HDCPCFG0_RXDETECT_ENABLE = 0x4,
-	HDMI_A_HDCPCFG0_RXDETECT_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_EN11FEATURE_MASK = 0x2,
-	HDMI_A_HDCPCFG0_EN11FEATURE_ENABLE = 0x2,
-	HDMI_A_HDCPCFG0_EN11FEATURE_DISABLE = 0x0,
-	HDMI_A_HDCPCFG0_HDMIDVI_MASK = 0x1,
-	HDMI_A_HDCPCFG0_HDMIDVI_HDMI = 0x1,
-	HDMI_A_HDCPCFG0_HDMIDVI_DVI = 0x0,
-
-/* A_HDCPCFG1 field values */
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_MASK = 0x8,
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_DISABLE = 0x8,
-	HDMI_A_HDCPCFG1_DISSHA1CHECK_ENABLE = 0x0,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_MASK = 0x4,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_ENABLE = 0x4,
-	HDMI_A_HDCPCFG1_PH2UPSHFTENC_DISABLE = 0x0,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_MASK = 0x2,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_DISABLE = 0x2,
-	HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE_ENABLE = 0x0,
-	HDMI_A_HDCPCFG1_SWRESET_MASK = 0x1,
-	HDMI_A_HDCPCFG1_SWRESET_ASSERT = 0x0,
-
-/* A_VIDPOLCFG field values */
-	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_MASK = 0x60,
-	HDMI_A_VIDPOLCFG_UNENCRYPTCONF_OFFSET = 5,
-	HDMI_A_VIDPOLCFG_DATAENPOL_MASK = 0x10,
-	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH = 0x10,
-	HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_LOW = 0x0,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_MASK = 0x8,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_HIGH = 0x8,
-	HDMI_A_VIDPOLCFG_VSYNCPOL_ACTIVE_LOW = 0x0,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_MASK = 0x2,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_HIGH = 0x2,
-	HDMI_A_VIDPOLCFG_HSYNCPOL_ACTIVE_LOW = 0x0,
-
-/* I2CM_OPERATION field values */
-	HDMI_I2CM_OPERATION_WRITE = 0x10,
-	HDMI_I2CM_OPERATION_READ_EXT = 0x2,
-	HDMI_I2CM_OPERATION_READ = 0x1,
-
-/* I2CM_INT field values */
-	HDMI_I2CM_INT_DONE_POL = 0x8,
-	HDMI_I2CM_INT_DONE_MASK = 0x4,
-
-/* I2CM_CTLINT field values */
-	HDMI_I2CM_CTLINT_NAC_POL = 0x80,
-	HDMI_I2CM_CTLINT_NAC_MASK = 0x40,
-	HDMI_I2CM_CTLINT_ARB_POL = 0x8,
-	HDMI_I2CM_CTLINT_ARB_MASK = 0x4,
-};
-
-/*
- * HDMI 3D TX PHY registers
- */
-#define HDMI_3D_TX_PHY_PWRCTRL			0x00
-#define HDMI_3D_TX_PHY_SERDIVCTRL		0x01
-#define HDMI_3D_TX_PHY_SERCKCTRL		0x02
-#define HDMI_3D_TX_PHY_SERCKKILLCTRL		0x03
-#define HDMI_3D_TX_PHY_TXRESCTRL		0x04
-#define HDMI_3D_TX_PHY_CKCALCTRL		0x05
-#define HDMI_3D_TX_PHY_CPCE_CTRL		0x06
-#define HDMI_3D_TX_PHY_TXCLKMEASCTRL		0x07
-#define HDMI_3D_TX_PHY_TXMEASCTRL		0x08
-#define HDMI_3D_TX_PHY_CKSYMTXCTRL		0x09
-#define HDMI_3D_TX_PHY_CMPSEQCTRL		0x0a
-#define HDMI_3D_TX_PHY_CMPPWRCTRL		0x0b
-#define HDMI_3D_TX_PHY_CMPMODECTRL		0x0c
-#define HDMI_3D_TX_PHY_MEASCTRL			0x0d
-#define HDMI_3D_TX_PHY_VLEVCTRL			0x0e
-#define HDMI_3D_TX_PHY_D2ACTRL			0x0f
-#define HDMI_3D_TX_PHY_CURRCTRL			0x10
-#define HDMI_3D_TX_PHY_DRVANACTRL		0x11
-#define HDMI_3D_TX_PHY_PLLMEASCTRL		0x12
-#define HDMI_3D_TX_PHY_PLLPHBYCTRL		0x13
-#define HDMI_3D_TX_PHY_GRP_CTRL			0x14
-#define HDMI_3D_TX_PHY_GMPCTRL			0x15
-#define HDMI_3D_TX_PHY_MPLLMEASCTRL		0x16
-#define HDMI_3D_TX_PHY_MSM_CTRL			0x17
-#define HDMI_3D_TX_PHY_SCRPB_STATUS		0x18
-#define HDMI_3D_TX_PHY_TXTERM			0x19
-#define HDMI_3D_TX_PHY_PTRPT_ENBL		0x1a
-#define HDMI_3D_TX_PHY_PATTERNGEN		0x1b
-#define HDMI_3D_TX_PHY_SDCAP_MODE		0x1c
-#define HDMI_3D_TX_PHY_SCOPEMODE		0x1d
-#define HDMI_3D_TX_PHY_DIGTXMODE		0x1e
-#define HDMI_3D_TX_PHY_STR_STATUS		0x1f
-#define HDMI_3D_TX_PHY_SCOPECNT0		0x20
-#define HDMI_3D_TX_PHY_SCOPECNT1		0x21
-#define HDMI_3D_TX_PHY_SCOPECNT2		0x22
-#define HDMI_3D_TX_PHY_SCOPECNTCLK		0x23
-#define HDMI_3D_TX_PHY_SCOPESAMPLE		0x24
-#define HDMI_3D_TX_PHY_SCOPECNTMSB01		0x25
-#define HDMI_3D_TX_PHY_SCOPECNTMSB2CK		0x26
-
-/* HDMI_3D_TX_PHY_CKCALCTRL values */
-#define HDMI_3D_TX_PHY_CKCALCTRL_OVERRIDE		BIT(15)
-
-/* HDMI_3D_TX_PHY_MSM_CTRL values */
-#define HDMI_3D_TX_PHY_MSM_CTRL_MPLL_PH_SEL_CK		BIT(13)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_CLK_REF_MPLL	(0 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_OFF		(1 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_PCLK		(2 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_CKO_SEL_FB_CLK		(3 << 1)
-#define HDMI_3D_TX_PHY_MSM_CTRL_SCOPE_CK_SEL		BIT(0)
-
-/* HDMI_3D_TX_PHY_PTRPT_ENBL values */
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_OVERRIDE		BIT(15)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT2		BIT(8)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT1		BIT(7)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_PG_SKIP_BIT0		BIT(6)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_CK_REF_ENB		BIT(5)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_RCAL_ENB		BIT(4)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_CLK_ALIGN_ENB	BIT(3)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_TX_READY		BIT(2)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_CKO_WORD_ENB		BIT(1)
-#define HDMI_3D_TX_PHY_PTRPT_ENBL_REFCLK_ENB		BIT(0)
-
-#endif /* __DW_HDMI_H__ */
diff --git a/drivers/video/nxp/imx/dw/dw_hdmi-imx.c b/drivers/video/nxp/imx/dw/dw_hdmi-imx.c
deleted file mode 100644
index ddf08b79b3..0000000000
--- a/drivers/video/nxp/imx/dw/dw_hdmi-imx.c
+++ /dev/null
@@ -1,421 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2011-2013 Freescale Semiconductor, Inc.
- *
- * derived from imx-hdmi.c(renamed to bridge/dw_hdmi.c now)
- */
-
-#include <common.h>
-#include <backlight.h>
-#include <clk.h>
-#include <display.h>
-#include <dm/device.h>
-#include <dm/read.h>
-#include <dm/device-internal.h>
-#include <generic-phy.h>
-#include <panel.h>
-#include <regmap.h>
-#include <reset.h>
-#include <syscon.h>
-#include <video_bridge.h>
-#include <video_link.h>
-#include "dw_hdmi.h"
-#include "imx8mp-hdmi-pavi.h"
-
-/* GPR reg */
-struct imx_hdmi_chip_data {
-	int	reg_offset;
-	u32	mask_bits;
-	u32	shift_bit;
-};
-
-struct imx_hdmi {
-	struct udevice *dev;
-	struct dw_hdmi *dw_hdmi;
-	struct regmap *regmap;
-	const struct imx_hdmi_chip_data *chip_data;
-	struct phy phy;
-#define PAVI	0
-#define PVI	1
-#define PAI	2
-	struct phy pavi[3];
-	int clock_cnt;
-	struct display_timing timings;
-	struct clk clks[12];
-};
-
-static const char *imx8mp_clocks[] = {
-	"pix_clk",
-	"phy_int",
-	"prep_clk",
-	"skp_clk",
-	"sfr_clk",
-	"cec_clk",
-	"apb_clk",
-	"hpi_clk",
-	"fdcc_ref",
-	"pipe_clk",
-};
-
-static const struct dw_hdmi_mpll_config imx_mpll_cfg[] = {
-	{
-		45250000, {
-			{ 0x01e0, 0x0000 },
-			{ 0x21e1, 0x0000 },
-			{ 0x41e2, 0x0000 }
-		},
-	}, {
-		92500000, {
-			{ 0x0140, 0x0005 },
-			{ 0x2141, 0x0005 },
-			{ 0x4142, 0x0005 },
-	},
-	}, {
-		148500000, {
-			{ 0x00a0, 0x000a },
-			{ 0x20a1, 0x000a },
-			{ 0x40a2, 0x000a },
-		},
-	}, {
-		216000000, {
-			{ 0x00a0, 0x000a },
-			{ 0x2001, 0x000f },
-			{ 0x4002, 0x000f },
-		},
-	}, {
-		~0UL, {
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-			{ 0x0000, 0x0000 },
-		},
-	}
-};
-
-static const struct dw_hdmi_curr_ctrl imx_cur_ctr[] = {
-	/*      pixelclk     bpp8    bpp10   bpp12 */
-	{
-		54000000, { 0x091c, 0x091c, 0x06dc },
-	}, {
-		58400000, { 0x091c, 0x06dc, 0x06dc },
-	}, {
-		72000000, { 0x06dc, 0x06dc, 0x091c },
-	}, {
-		74250000, { 0x06dc, 0x0b5c, 0x091c },
-	}, {
-		118800000, { 0x091c, 0x091c, 0x06dc },
-	}, {
-		216000000, { 0x06dc, 0x0b5c, 0x091c },
-	}, {
-		~0UL, { 0x0000, 0x0000, 0x0000 },
-	},
-};
-
-/*
- * Resistance term 133Ohm Cfg
- * PREEMP config 0.00
- * TX/CK level 10
- */
-static const struct dw_hdmi_phy_config imx6_phy_config[] = {
-	/*pixelclk   symbol   term   vlev */
-	{ 216000000, 0x800d, 0x0005, 0x01ad},
-	{ ~0UL,      0x0000, 0x0000, 0x0000}
-};
-
-static void dw_hdmi_imx_encoder_enable(struct imx_hdmi *hdmi, int mux)
-{
-	if (hdmi->chip_data->reg_offset < 0)
-		return;
-
-	regmap_update_bits(hdmi->regmap, hdmi->chip_data->reg_offset,
-			   hdmi->chip_data->mask_bits, mux << hdmi->chip_data->shift_bit);
-}
-
-
-#define IOMUXC_GPR3			0x0c
-#define IMX6Q_GPR3_HDMI_MUX_CTL_MASK	(0x3 << 2)
-#define IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT	2
-
-struct imx_hdmi_chip_data imx6_chip_data = {
-	.reg_offset = IOMUXC_GPR3,
-	.mask_bits = IMX6Q_GPR3_HDMI_MUX_CTL_MASK,
-	.shift_bit = IMX6Q_GPR3_HDMI_MUX_CTL_SHIFT,
-};
-
-static struct dw_hdmi_plat_data imx6q_hdmi_drv_data = {
-	.mpll_cfg   = imx_mpll_cfg,
-	.cur_ctr    = imx_cur_ctr,
-	.phy_config = imx6_phy_config,
-	.phy_data   = &imx6_chip_data,
-	.phy_min_clock =  13500000,
-	.phy_max_clock = 216000000,	/* FIXME: Hardware is capable of 266MHz, but setup data is missing. */
-};
-
-static struct dw_hdmi_plat_data imx6dl_hdmi_drv_data = {
-	.mpll_cfg = imx_mpll_cfg,
-	.cur_ctr  = imx_cur_ctr,
-	.phy_config = imx6_phy_config,
-	.phy_data   = &imx6_chip_data,
-	.phy_min_clock =  13500000,
-	.phy_max_clock = 216000000,	/* FIXME: Hardware is capable of 266MHz, but setup data is missing. */
-};
-
-static int imx8mp_hdmi_phy_init(struct dw_hdmi *dw_hdmi, void *data, const struct display_timing *mode)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dw_hdmi_get_dev(dw_hdmi));
-	struct imx8mp_hdmi_pavi *pavi = dev_get_priv(hdmi->pavi[PVI].dev);
-	unsigned int val;
-
-	dw_hdmi_phy_reset(dw_hdmi);
-
-	pavi->flags = hdmi->timings.flags;
-	/* enable PVI */
-	generic_phy_power_on(&hdmi->pavi[PAVI]);
-	generic_phy_power_on(&hdmi->pavi[PVI]);
-
-	/* HDMI PHY power up */
-	regmap_read(hdmi->regmap, 0x200, &val);
-	val &= ~0x8;
-	/* Enable CEC */
-	val |= 0x2;
-	regmap_write(hdmi->regmap, 0x200, val);
-
-	if (!hdmi->phy.dev)
-		return 0;
-
-	generic_phy_power_on(&hdmi->phy);
-
-	return 0;
-}
-
-static void imx8mp_hdmi_phy_disable(struct dw_hdmi *dw_hdmi, void *data)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dw_hdmi_get_dev(dw_hdmi));
-	unsigned int val;
-
-	if (!hdmi->phy.dev)
-		return;
-
-	/* disable PVI */
-	generic_phy_power_off(&hdmi->pavi[PVI]);
-	generic_phy_power_off(&hdmi->pavi[PAVI]);
-
-	/* TODO */
-	regmap_read(hdmi->regmap, 0x200, &val);
-	/* Disable CEC */
-	val &= ~0x2;
-	/* Power down HDMI PHY */
-	val |= 0x8;
-	regmap_write(hdmi->regmap, 0x200, val);
-}
-
-static int imx8mp_hdmimix_setup(struct imx_hdmi *hdmi)
-{
-	int ret;
-	int i;
-
-	ret = device_reset(hdmi->dev);
-
-	hdmi->clock_cnt = ARRAY_SIZE(imx8mp_clocks);
-	for (i = 0; i < hdmi->clock_cnt; i++) {
-		ret = clk_get_by_name(hdmi->dev, imx8mp_clocks[i],
-				&hdmi->clks[i]);
-		if (ret < 0) {
-			printf("%s: %s clk missing %d\n", __func__,
-				imx8mp_clocks[i], ret);
-			return ret;
-		}
-	}
-
-	for (i = 0; i < hdmi->clock_cnt; i++) {
-		ret = clk_prepare_enable(&hdmi->clks[i]);
-		if (ret < 0) {
-			printf("%s enable %s failed %d\n", __func__,
-				imx8mp_clocks[i], ret);
-			return ret;
-		}
-	}
-//	clk_set_rate(&hdmi->clks[0], rate);
-	return 0;
-}
-
-void imx8mp_hdmi_enable_audio(struct dw_hdmi *dw_hdmi, void *data, int channel,
-			      int width, int rate, int non_pcm)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dw_hdmi_get_dev(dw_hdmi));
-	struct imx8mp_hdmi_pavi *pavi = dev_get_priv(hdmi->pavi[PAI].dev);
-
-	pavi->channel = channel;
-	pavi->width = width;
-	pavi->rate = rate;
-	pavi->non_pcm = non_pcm;
-	generic_phy_power_on(&hdmi->pavi[PAI]);
-}
-
-void imx8mp_hdmi_disable_audio(struct dw_hdmi *dw_hdmi, void *data)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dw_hdmi_get_dev(dw_hdmi));
-
-	generic_phy_power_off(&hdmi->pavi[PAI]);
-}
-
-static const struct dw_hdmi_phy_ops imx8mp_hdmi_phy_ops = {
-	.init		= imx8mp_hdmi_phy_init,
-	.disable	= imx8mp_hdmi_phy_disable,
-	.read_hpd = dw_hdmi_phy_read_hpd,
-	.update_hpd = dw_hdmi_phy_update_hpd,
-	.setup_hpd = dw_hdmi_phy_setup_hpd,
-	.enable_audio	= imx8mp_hdmi_enable_audio,
-	.disable_audio  = imx8mp_hdmi_disable_audio,
-};
-
-struct imx_hdmi_chip_data imx8mp_chip_data = {
-	.reg_offset = -1,
-};
-
-static const struct dw_hdmi_plat_data imx8mp_hdmi_drv_data = {
-	.phy_data   = &imx8mp_chip_data,
-	.phy_ops    = &imx8mp_hdmi_phy_ops,
-	.phy_name   = "samsung_dw_hdmi_phy2",
-	.phy_force_vendor = true,
-	.mix_setup = true,
-	.phy_min_clock =  13500000,
-	.phy_max_clock = 297000000,
-};
-
-static const struct udevice_id dw_hdmi_imx_dt_ids[] = {
-	{ .compatible = "fsl,imx6q-hdmi",
-	  .data = (long)&imx6q_hdmi_drv_data
-	}, {
-	  .compatible = "fsl,imx6dl-hdmi",
-	  .data = (long)&imx6dl_hdmi_drv_data
-	}, {
-	  .compatible = "fsl,imx8mp-hdmi",
-	  .data = (long)&imx8mp_hdmi_drv_data
-	},
-	{},
-};
-
-static int dw_hdmi_imx_read_timing(struct udevice *dev, struct display_timing *timing)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dev);
-
-	if (timing) {
-		memcpy(timing, &hdmi->timings, sizeof(struct display_timing));
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int dw_hdmi_imx_enable(struct udevice *dev, int panel_bpp,
-		      const struct display_timing *timing)
-{
-	const struct dw_hdmi_plat_data *pdata =
-		(struct dw_hdmi_plat_data *)dev_get_driver_data(dev);
-	struct imx_hdmi *hdmi = dev_get_priv(dev);
-	int ret;
-
-	ret = pdata->phy_ops->init(hdmi->dw_hdmi, hdmi, timing);
-	if (ret) {
-		printf("HDMI enable failed, ret %d!\n", ret);
-		return ret;
-	}
-	dw_hdmi_imx_encoder_enable(hdmi, 0);
-	dw_hdmi_bridge_enable(hdmi->dw_hdmi);
-	return 0;
-}
-
-static const char* mix_phys[] = { "pavi", "pvi", "pai" };
-
-static int dw_hdmi_imx_parse_dt(struct imx_hdmi *hdmi)
-{
-	const struct dw_hdmi_plat_data *pdata =
-		(struct dw_hdmi_plat_data *)dev_get_driver_data(hdmi->dev);
-	ofnode np = dev_ofnode(hdmi->dev);
-	int ret;
-	int i;
-
-	hdmi->regmap = syscon_regmap_lookup_by_phandle(hdmi->dev, "gpr");
-	if (IS_ERR(hdmi->regmap)) {
-		printf("Unable to get gpr\n");
-		return PTR_ERR(hdmi->regmap);
-	}
-
-	ret = ofnode_generic_phy_get_by_name(np, "hdmi", &hdmi->phy);
-	if (ret) {
-		printf("%s: can't get phy: %d\n", __func__, ret);
-		return ret;
-	}
-	if (pdata->mix_setup) {
-		for (i = 0; i < ARRAY_SIZE(mix_phys); i++) {
-			ret = ofnode_generic_phy_get_by_name(np, mix_phys[i],
-					&hdmi->pavi[i]);
-			if (ret) {
-				printf("%s: can't get %s: %d\n", __func__,
-					mix_phys[i], ret);
-				return ret;
-			}
-		}
-	}
-	return 0;
-}
-
-static int dw_hdmi_imx_bind(struct udevice *dev)
-{
-	const struct dw_hdmi_plat_data *pdata =
-		(struct dw_hdmi_plat_data *)dev_get_driver_data(dev);
-	struct imx_hdmi *hdmi = dev_get_priv(dev);
-	int ret;
-
-	hdmi->dev = dev;
-	hdmi->chip_data = pdata->phy_data;
-
-	ret = dw_hdmi_imx_parse_dt(hdmi);
-	if (ret < 0)
-		return ret;
-
-	if (pdata->mix_setup) {
-		ret = imx8mp_hdmimix_setup(hdmi);
-		if (ret < 0)
-			return ret;
-	}
-
-	hdmi->dw_hdmi = dw_hdmi_bind(dev, pdata);
-	return ret;
-}
-
-static void dw_hdmi_imx_unbind(struct udevice *dev)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dev);
-
-	dw_hdmi_unbind(hdmi->dw_hdmi);
-}
-
-static int dw_hdmi_imx_probe(struct udevice *dev)
-{
-	return dw_hdmi_imx_bind(dev);
-}
-
-static int dw_hdmi_imx_remove(struct udevice *dev)
-{
-	struct imx_hdmi *hdmi = dev_get_priv(dev);
-
-	dw_hdmi_bridge_disable(hdmi->dw_hdmi);
-	dw_hdmi_imx_unbind(dev);
-	return 0;
-}
-
-struct dm_display_ops dw_hdmi_ops = {
-	.read_timing = dw_hdmi_imx_read_timing,
-	.enable = dw_hdmi_imx_enable,
-};
-
-U_BOOT_DRIVER(dw_hdmi_imx) = {
-	.name				= "dwhdmi-imx",
-	.id				= UCLASS_DISPLAY,
-	.of_match			= dw_hdmi_imx_dt_ids,
-	.bind				= dm_scan_fdt_dev,
-	.probe				= dw_hdmi_imx_probe,
-	.remove				= dw_hdmi_imx_remove,
-	.ops				= &dw_hdmi_ops,
-	.priv_auto			= sizeof(struct imx_hdmi),
-};
diff --git a/drivers/video/nxp/imx/dw/dw_hdmi.h b/drivers/video/nxp/imx/dw/dw_hdmi.h
deleted file mode 100644
index d70bfe9625..0000000000
--- a/drivers/video/nxp/imx/dw/dw_hdmi.h
+++ /dev/null
@@ -1,225 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
- */
-
-#ifndef __DW_HDMI__
-#define __DW_HDMI__
-
-
-struct dw_hdmi;
-
-enum v4l2_ycbcr_encoding {
-	/*
-	 * Mapping of V4L2_YCBCR_ENC_DEFAULT to actual encodings for the
-	 * various colorspaces:
-	 *
-	 * V4L2_COLORSPACE_SMPTE170M, V4L2_COLORSPACE_470_SYSTEM_M,
-	 * V4L2_COLORSPACE_470_SYSTEM_BG, V4L2_COLORSPACE_SRGB,
-	 * V4L2_COLORSPACE_OPRGB and V4L2_COLORSPACE_JPEG: V4L2_YCBCR_ENC_601
-	 *
-	 * V4L2_COLORSPACE_REC709 and V4L2_COLORSPACE_DCI_P3: V4L2_YCBCR_ENC_709
-	 *
-	 * V4L2_COLORSPACE_BT2020: V4L2_YCBCR_ENC_BT2020
-	 *
-	 * V4L2_COLORSPACE_SMPTE240M: V4L2_YCBCR_ENC_SMPTE240M
-	 */
-	V4L2_YCBCR_ENC_DEFAULT		= 0,
-
-	/* ITU-R 601 -- SDTV */
-	V4L2_YCBCR_ENC_601		= 1,
-
-	/* Rec. 709 -- HDTV */
-	V4L2_YCBCR_ENC_709		= 2,
-
-	/* ITU-R 601/EN 61966-2-4 Extended Gamut -- SDTV */
-	V4L2_YCBCR_ENC_XV601		= 3,
-
-	/* Rec. 709/EN 61966-2-4 Extended Gamut -- HDTV */
-	V4L2_YCBCR_ENC_XV709		= 4,
-
-	/* BT.2020 Non-constant Luminance Y'CbCr */
-	V4L2_YCBCR_ENC_BT2020		= 6,
-
-	/* BT.2020 Constant Luminance Y'CbcCrc */
-	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
-
-	/* SMPTE 240M -- Obsolete HDTV */
-	V4L2_YCBCR_ENC_SMPTE240M	= 8,
-
-	/* KR=0.30, KB=0.11 or equivalent */
-	V4L2_YCBCR_ENC_BT470_6M		= 9,
-};
-
-/**
- * DOC: Supported input formats and encodings
- *
- * Depending on the Hardware configuration of the Controller IP, it supports
- * a subset of the following input formats and encodings on its internal
- * 48bit bus.
- *
- * +----------------------+----------------------------------+------------------------------+
- * | Format Name          | Format Code                      | Encodings                    |
- * +----------------------+----------------------------------+------------------------------+
- * | RGB 4:4:4 8bit       | ``MEDIA_BUS_FMT_RGB888_1X24``    | ``V4L2_YCBCR_ENC_DEFAULT``   |
- * +----------------------+----------------------------------+------------------------------+
- * | RGB 4:4:4 10bits     | ``MEDIA_BUS_FMT_RGB101010_1X30`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
- * +----------------------+----------------------------------+------------------------------+
- * | RGB 4:4:4 12bits     | ``MEDIA_BUS_FMT_RGB121212_1X36`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
- * +----------------------+----------------------------------+------------------------------+
- * | RGB 4:4:4 16bits     | ``MEDIA_BUS_FMT_RGB161616_1X48`` | ``V4L2_YCBCR_ENC_DEFAULT``   |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:4:4 8bit     | ``MEDIA_BUS_FMT_YUV8_1X24``      | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:4:4 10bits   | ``MEDIA_BUS_FMT_YUV10_1X30``     | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:4:4 12bits   | ``MEDIA_BUS_FMT_YUV12_1X36``     | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:4:4 16bits   | ``MEDIA_BUS_FMT_YUV16_1X48``     | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV601``  |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_XV709``  |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:2 8bit     | ``MEDIA_BUS_FMT_UYVY8_1X16``     | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:2 10bits   | ``MEDIA_BUS_FMT_UYVY10_1X20``    | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:2 12bits   | ``MEDIA_BUS_FMT_UYVY12_1X24``    | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:0 8bit     | ``MEDIA_BUS_FMT_UYYVYY8_0_5X24`` | ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:0 10bits   | ``MEDIA_BUS_FMT_UYYVYY10_0_5X30``| ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:0 12bits   | ``MEDIA_BUS_FMT_UYYVYY12_0_5X36``| ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- * | YCbCr 4:2:0 16bits   | ``MEDIA_BUS_FMT_UYYVYY16_0_5X48``| ``V4L2_YCBCR_ENC_601``       |
- * |                      |                                  | or ``V4L2_YCBCR_ENC_709``    |
- * +----------------------+----------------------------------+------------------------------+
- */
-
-enum {
-	DW_HDMI_RES_8,
-	DW_HDMI_RES_10,
-	DW_HDMI_RES_12,
-	DW_HDMI_RES_MAX,
-};
-
-enum dw_hdmi_phy_type {
-	DW_HDMI_PHY_DWC_HDMI_TX_PHY = 0x00,
-	DW_HDMI_PHY_DWC_MHL_PHY_HEAC = 0xb2,
-	DW_HDMI_PHY_DWC_MHL_PHY = 0xc2,
-	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY_HEAC = 0xe2,
-	DW_HDMI_PHY_DWC_HDMI_3D_TX_PHY = 0xf2,
-	DW_HDMI_PHY_DWC_HDMI20_TX_PHY = 0xf3,
-	DW_HDMI_PHY_VENDOR_PHY = 0xfe,
-};
-
-struct dw_hdmi_mpll_config {
-	unsigned long mpixelclock;
-	struct {
-		u16 cpce;
-		u16 gmp;
-	} res[DW_HDMI_RES_MAX];
-};
-
-struct dw_hdmi_curr_ctrl {
-	unsigned long mpixelclock;
-	u16 curr[DW_HDMI_RES_MAX];
-};
-
-struct dw_hdmi_phy_config {
-	unsigned long mpixelclock;
-	u16 sym_ctr;    /*clock symbol and transmitter control*/
-	u16 term;       /*transmission termination value*/
-	u16 vlev_ctr;   /* voltage level control */
-};
-
-struct dw_hdmi_phy_ops {
-	int (*init)(struct dw_hdmi *hdmi, void *data, const struct display_timing *mode);
-	void (*disable)(struct dw_hdmi *hdmi, void *data);
-	int (*read_hpd)(struct dw_hdmi *hdmi, void *data);
-	void (*update_hpd)(struct dw_hdmi *hdmi, void *data,
-			   bool force, bool disabled, bool rxsense);
-	void (*setup_hpd)(struct dw_hdmi *hdmi, void *data);
-	void (*enable_audio)(struct dw_hdmi *hdmi, void *data, int channel,
-			     int width, int rate, int non_pcm);
-	void (*disable_audio)(struct dw_hdmi *hdmi, void *data);
-};
-
-struct dw_hdmi_plat_data {
-	struct regmap *regm;
-	unsigned long input_bus_format;
-	unsigned long input_bus_encoding;
-
-	/* Vendor PHY support */
-	const struct dw_hdmi_phy_ops *phy_ops;
-	const char *phy_name;
-	void *phy_data;
-	unsigned int phy_force_vendor;
-	unsigned int mix_setup;
-	u32	phy_min_clock;
-	u32	phy_max_clock;
-
-	/* Synopsys PHY support */
-	const struct dw_hdmi_mpll_config *mpll_cfg;
-	const struct dw_hdmi_curr_ctrl *cur_ctr;
-	const struct dw_hdmi_phy_config *phy_config;
-	int (*configure_phy)(struct dw_hdmi *hdmi,
-			     const struct dw_hdmi_plat_data *pdata,
-			     unsigned long mpixelclock);
-};
-
-struct dw_hdmi *dw_hdmi_probe(struct udevice *dev, const struct dw_hdmi_plat_data *plat_data);
-void dw_hdmi_remove(struct dw_hdmi *hdmi);
-void dw_hdmi_unbind(struct dw_hdmi *hdmi);
-struct dw_hdmi *dw_hdmi_bind(struct udevice *dev, const struct dw_hdmi_plat_data *pdata);
-
-void dw_hdmi_resume(struct dw_hdmi *hdmi);
-
-void dw_hdmi_setup_rx_sense(struct dw_hdmi *hdmi, bool hpd, bool rx_sense);
-
-void dw_hdmi_set_sample_non_pcm(struct dw_hdmi *hdmi, unsigned int non_pcm);
-void dw_hdmi_set_sample_width(struct dw_hdmi *hdmi, unsigned int width);
-void dw_hdmi_set_sample_rate(struct dw_hdmi *hdmi, unsigned int rate);
-void dw_hdmi_set_channel_count(struct dw_hdmi *hdmi, unsigned int cnt);
-void dw_hdmi_set_channel_allocation(struct dw_hdmi *hdmi, unsigned int ca);
-void dw_hdmi_audio_enable(struct dw_hdmi *hdmi);
-void dw_hdmi_audio_disable(struct dw_hdmi *hdmi);
-void dw_hdmi_set_high_tmds_clock_ratio(struct dw_hdmi *hdmi);
-
-/* PHY configuration */
-void dw_hdmi_phy_i2c_set_addr(struct dw_hdmi *hdmi, u8 address);
-void dw_hdmi_phy_i2c_write(struct dw_hdmi *hdmi, unsigned short data,
-			   unsigned char addr);
-
-void dw_hdmi_phy_reset(struct dw_hdmi *hdmi);
-
-void dw_hdmi_phy_gen2_pddq(struct dw_hdmi *hdmi, u8 enable);
-void dw_hdmi_phy_gen2_txpwron(struct dw_hdmi *hdmi, u8 enable);
-void dw_hdmi_phy_gen2_reset(struct dw_hdmi *hdmi);
-
-struct udevice* dw_hdmi_get_dev(struct dw_hdmi *hdmi);
-int dw_hdmi_phy_read_hpd(struct dw_hdmi *hdmi, void *data);
-void dw_hdmi_phy_update_hpd(struct dw_hdmi *hdmi, void *data,
-			    bool force, bool disabled, bool rxsense);
-void dw_hdmi_phy_setup_hpd(struct dw_hdmi *hdmi, void *data);
-void dw_hdmi_bridge_enable(struct dw_hdmi *hdmi);
-void dw_hdmi_bridge_disable(struct dw_hdmi *hdmi);
-
-
-#endif /* __IMX_HDMI_H__ */
diff --git a/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.c b/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.c
deleted file mode 100644
index 676b3022cf..0000000000
--- a/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.c
+++ /dev/null
@@ -1,236 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright 2020 NXP
- *
- * Programe Video/Audio Interface between LCDIF and HDMI Ctrl in HDMIMIX
- *
- */
-
-#include <common.h>
-#include <clk.h>
-#include <dm/device.h>
-#include <dm/device_compat.h>
-#include <dm/read.h>
-#include <fdtdec.h>
-#include <generic-phy.h>
-#include <linux/io.h>
-#include <reset.h>
-#include "imx8mp-hdmi-pavi.h"
-
-#define HTX_PVI_CTRL         0x0
-#define HTX_PVI_IRQ_MASK     0x04
-#define HTX_TMG_GEN_DISP_LRC 0x10
-#define HTX_TMG_GEN_DE_ULC   0x14
-#define HTX_TMG_GEN_DE_LRC   0x18
-#define HTX_TMG_GEN_HSYNC    0x1c
-#define HTX_TMG_GEN_VSYNC    0x20
-#define HTX_TMG_GEN_IRQ0     0x24
-#define HTX_TMG_GEN_IRQ1     0x28
-#define HTX_TMG_GEN_IRQ2     0x2c
-#define HTX_TMG_GEN_IRQ3     0x30
-#define HTX_TMG_GEN_CFG      0x40
-
-#define HTX_PAI_CTRL        0x800
-#define HTX_PAI_CTRL_EXT    0x804
-#define HTX_PAI_FIELD_CTRL  0x808
-
-#define HTX_PAI_CTRL_ENABLE 1
-
-/* PAI APIs  */
-static int imx8mp_hdmi_pai_enable(struct imx8mp_hdmi_pavi *pavi)
-{
-	/* PAI set */
-	writel((0x3030000 | ((pavi->channel - 1) << 8)),
-			pavi->base + HTX_PAI_CTRL_EXT);
-
-	/* hbr */
-	if (pavi->non_pcm && pavi->width == 32 && pavi->channel == 8 && pavi->rate == 192000)
-		writel(0x004e77df, pavi->base + HTX_PAI_FIELD_CTRL);
-	else if (pavi->width == 32)
-		writel(0x1c8c675b, pavi->base + HTX_PAI_FIELD_CTRL);
-	else
-		writel(0x1c0c675b, pavi->base + HTX_PAI_FIELD_CTRL);
-
-	/* PAI start running */
-	writel(HTX_PAI_CTRL_ENABLE, pavi->base + HTX_PAI_CTRL);
-	return 0;
-}
-
-static int imx8mp_hdmi_pai_disable(struct imx8mp_hdmi_pavi *pavi)
-{
-	/* stop PAI */
-	writel(0, pavi->base + HTX_PAI_CTRL);
-	return 0;
-}
-
-/* PVI APIs  */
-static int imx8mp_hdmi_pvi_enable(struct imx8mp_hdmi_pavi *pavi)
-{
-	writel(0x00000003, pavi->base + HTX_PVI_IRQ_MASK);
-	writel(0x08970464, pavi->base + HTX_TMG_GEN_DISP_LRC);
-	writel(0x00bf0029, pavi->base + HTX_TMG_GEN_DE_ULC);
-	writel(0x083f0460, pavi->base + HTX_TMG_GEN_DE_LRC);
-	writel(0x0897002b, pavi->base + HTX_TMG_GEN_HSYNC);
-	writel(0x04640004, pavi->base + HTX_TMG_GEN_VSYNC);
-	writel(0x000100ff, pavi->base + HTX_TMG_GEN_IRQ0);
-	writel(0x000100f0, pavi->base + HTX_TMG_GEN_IRQ1);
-	writel(0x00010315, pavi->base + HTX_TMG_GEN_IRQ2);
-	writel(0x00010207, pavi->base + HTX_TMG_GEN_IRQ3);
-	writel(0x84640000, pavi->base + HTX_TMG_GEN_CFG);
-
-	/* DE/VSYN/HSYNC pol */
-	if ((pavi->flags & DISPLAY_FLAGS_VSYNC_HIGH) &&
-			(pavi->flags & DISPLAY_FLAGS_HSYNC_HIGH)) {
-		writel(0x00377004, pavi->base + HTX_PVI_CTRL);
-		writel(0x00377005, pavi->base + HTX_PVI_CTRL);
-	} else {
-		writel(0x00311004, pavi->base + HTX_PVI_CTRL);
-		writel(0x00311005, pavi->base + HTX_PVI_CTRL);
-	}
-	return 0;
-}
-
-static int imx8mp_hdmi_pvi_disable(struct imx8mp_hdmi_pavi *pavi)
-{
-	/* Stop PVI */
-	writel(0x0, pavi->base + HTX_PVI_CTRL);
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_phy_init(struct phy *phy)
-{
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_phy_power_on(struct phy *phy)
-{
-	struct imx8mp_hdmi_pavi *pavi = dev_get_priv(phy->dev);
-
-	debug("%s: phy_id = %ld\n", __func__, phy->id);
-	if (phy->id == 1)
-		return imx8mp_hdmi_pvi_enable(pavi);
-	else if (phy->id == 2)
-		return imx8mp_hdmi_pai_enable(pavi);
-
-	clk_prepare_enable(pavi->clk_pvi);
-	clk_prepare_enable(pavi->clk_pai);
-
-	/* deassert pai reset */
-	if (!pavi->reset_pai)
-		reset_deassert(pavi->reset_pai);
-
-	/* deassert pvi reset */
-	if (!pavi->reset_pvi)
-		reset_deassert(pavi->reset_pvi);
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_phy_power_off(struct phy *phy)
-{
-	struct imx8mp_hdmi_pavi *pavi = dev_get_priv(phy->dev);
-
-	debug("%s: phy_id = %ld\n", __func__, phy->id);
-	if (phy->id == 1)
-		return imx8mp_hdmi_pvi_disable(pavi);
-	else if (phy->id == 2)
-		return imx8mp_hdmi_pai_disable(pavi);
-
-	/* set pvi reset */
-	if (!pavi->reset_pvi)
-		reset_assert(pavi->reset_pvi);
-
-	/* set pai reset */
-	if (!pavi->reset_pai)
-		reset_assert(pavi->reset_pai);
-
-	clk_disable_unprepare(pavi->clk_pai);
-	clk_disable_unprepare(pavi->clk_pvi);
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_phy_xlate(struct phy *phy,
-		struct ofnode_phandle_args *args)
-{
-	if (args->args_count)
-		phy->id = args->args[0];
-	else
-		phy->id = 0;
-
-	if (phy->id > 2)
-		return -EINVAL;
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_probe(struct udevice *dev)
-{
-	struct imx8mp_hdmi_pavi *pavi = dev_get_priv(dev);
-	int ret;
-
-	debug("%s: probe begin\n", __func__);
-
-	pavi->dev = dev;
-	pavi->base = (void *)dev_read_addr(dev);
-	if (IS_ERR(pavi->base))
-		return PTR_ERR(pavi->base);
-
-	pavi->clk_pvi = devm_clk_get(dev, "pvi_clk");
-	if (IS_ERR(pavi->clk_pvi)) {
-		ret = PTR_ERR(pavi->clk_pvi);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "pvi clock failed %d\n", ret);
-		return ret;
-	}
-
-	pavi->clk_pai = devm_clk_get(dev, "pai_clk");
-	if (IS_ERR(pavi->clk_pai)) {
-		ret = PTR_ERR(pavi->clk_pai);
-		if (ret != -EPROBE_DEFER)
-			dev_err(dev, "pai clock failed %d\n", ret);
-		return ret;
-	}
-
-	pavi->reset_pai = devm_reset_control_get(dev, "pai_rst");
-	if (IS_ERR(pavi->reset_pai)) {
-		ret = PTR_ERR(pavi->reset_pai);
-		debug("PAI reset failed %d\n", ret);
-		return ret;
-	}
-
-	pavi->reset_pvi = devm_reset_control_get(dev, "pvi_rst");
-	if (IS_ERR(pavi->reset_pvi)) {
-		ret = PTR_ERR(pavi->reset_pvi);
-		debug("PVI reset failed %d\n", ret);
-		return ret;
-	}
-
-	debug("%s: probe success\n", __func__);
-	return 0;
-}
-
-static int imx8mp_hdmi_pavi_remove(struct udevice *dev)
-{
-	return 0;
-}
-
-static const struct udevice_id imx8mp_hdmi_pavi_dt_ids[] = {
-	{ .compatible = "fsl,imx8mp-hdmi-pavi", },
-	{ /* sentinel */ }
-};
-
-static const struct phy_ops imx8mp_hdmi_pavi_phy_ops = {
-	.of_xlate = imx8mp_hdmi_pavi_phy_xlate,
-	.init = imx8mp_hdmi_pavi_phy_init,
-	.power_on = imx8mp_hdmi_pavi_phy_power_on,
-	.power_off = imx8mp_hdmi_pavi_phy_power_off,
-};
-
-U_BOOT_DRIVER(imx8mp_hdmi_pavi) = {
-	.name				= "imx8mp-hdmi-pavi",
-	.id				= UCLASS_PHY,
-	.of_match			= imx8mp_hdmi_pavi_dt_ids,
-	.ops = &imx8mp_hdmi_pavi_phy_ops,
-	.bind				= dm_scan_fdt_dev,
-	.probe				= imx8mp_hdmi_pavi_probe,
-	.remove				= imx8mp_hdmi_pavi_remove,
-	.priv_auto			= sizeof(struct imx8mp_hdmi_pavi),
-};
diff --git a/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.h b/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.h
deleted file mode 100644
index a4c6abc38c..0000000000
--- a/drivers/video/nxp/imx/dw/imx8mp-hdmi-pavi.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
-/*
- * Copyright 2020 NXP
- *
- * PAI/PVI Head file
- *
- */
-#ifndef _IMX8MP_HDMI_AV_CTL_H_
-#define _IMX8MP_HDMI_AV_CTL_H_
-
-struct imx8mp_hdmi_pavi {
-	struct udevice *dev;
-
-	void __iomem *base;
-	int rpm_suspended;
-
-	struct clk *clk_pai;
-	struct clk *clk_pvi;
-	struct reset_ctl *reset_pai;
-	struct reset_ctl *reset_pvi;
-	enum display_flags flags;
-	int channel;
-	int width;
-	int rate;
-	int non_pcm;
-};
-#endif /* _IMX8MP_HDMI_PAVI_H_ */
diff --git a/drivers/video/nxp/imx/imx8mp_lvds.c b/drivers/video/nxp/imx/imx8mp_lvds.c
deleted file mode 100644
index 8c98c50eeb..0000000000
--- a/drivers/video/nxp/imx/imx8mp_lvds.c
+++ /dev/null
@@ -1,281 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * Copyright 2022 NXP
- */
-#include <common.h>
-#include <clk.h>
-#include <dm.h>
-#include <dm/device_compat.h>
-#include <display.h>
-#include <video.h>
-#include <video_bridge.h>
-#include <video_link.h>
-#include <asm/io.h>
-#include <dm/device-internal.h>
-#include <linux/iopoll.h>
-#include <linux/err.h>
-#include <clk.h>
-
-#include <power-domain.h>
-#include <regmap.h>
-#include <syscon.h>
-
-#define DRIVER_NAME "imx8mp-ldb"
-
-
-#define LVDS_CTRL		0x128
-#define HS_DISABLE		(0 << 3)
-#define SPARE_IN(n)		(((n) & 0x7) << 25)
-#define SPARE_IN_MASK		0xe000000
-#define TEST_RANDOM_NUM_EN	BIT(24)
-#define TEST_MUX_SRC(n)		(((n) & 0x3) << 22)
-#define TEST_MUX_SRC_MASK	0xc00000
-#define TEST_EN			BIT(21)
-#define TEST_DIV4_EN		BIT(20)
-#define VBG_ADJ(n)		(((n) & 0x7) << 17)
-#define VBG_ADJ_MASK		0xe0000
-#define SLEW_ADJ(n)		(((n) & 0x7) << 14)
-#define SLEW_ADJ_MASK		0x1c000
-#define CC_ADJ(n)		(((n) & 0x7) << 11)
-#define CC_ADJ_MASK		0x3800
-#define CM_ADJ(n)		(((n) & 0x7) << 8)
-#define CM_ADJ_MASK		0x700
-#define PRE_EMPH_ADJ(n)		(((n) & 0x7) << 5)
-#define PRE_EMPH_ADJ_MASK	0xe0
-#define PRE_EMPH_EN		BIT(4)
-#define HS_EN			BIT(3)
-#define BG_EN			BIT(2)
-#define CH_EN		    BIT(0)
-
-
-#define LDB_CTRL		0x5c
-#define LDB_CH0_MODE_EN_TO_DI0		(1 << 0)
-#define LDB_CH0_MODE_EN_TO_DI1		(3 << 0)
-#define LDB_CH0_MODE_EN_MASK		(3 << 0)
-#define LDB_CH1_MODE_EN_TO_DI0		(1 << 2)
-#define LDB_CH1_MODE_EN_TO_DI1		(3 << 2)
-#define LDB_CH1_MODE_EN_MASK		(3 << 2)
-#define CH0_DATA_WIDTH_24BIT		(1 << 5)
-#define CH0_BIT_MAPPING_JEIDA		(1 << 6)
-#define CH0_BIT_MAPPING_SPWG		(0 << 6)
-#define LDB_REG_CH0_FIFO_RESET		(1 << 11)
-#define LDB_REG_CH1_FIFO_RESET		(1 << 12)
-#define LDB_REG_ASYNC_FIFO_EN		(1 << 24)
-#define LDB_FIFO_THRESHOLD		(4 << 25)
-
-#define CLK_EN 0x4
-
-#define usleep_range(a, b) udelay((b))
-
-#define serial_clk 74250*7000
-
-struct imx8mp_ldb_priv {
-	struct regmap *regmap;
-	struct udevice *conn_dev;
-	unsigned int ldb_id;
-	struct clk *ldb_root_clk;
-	struct clk *apb_root_clk;
-	struct display_timing timings;
-};
-
-
-static inline unsigned int media_blk_read(struct imx8mp_ldb_priv *priv, unsigned int reg)
-{
-	unsigned int val;
-
-	regmap_read(priv->regmap, reg, &val);
-
-	return val;
-}
-
-static inline void media_blk_write(struct imx8mp_ldb_priv *priv, unsigned int reg, unsigned int value)
-{
-	regmap_write(priv->regmap, reg, value);
-}
-
-static int imx8mp_lvds_phy_power_on(struct udevice *dev)
-{
-	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
-	
-	unsigned int val;
-	u32 ldb_ctrl;
-	bool bg_en;
-
- 	media_blk_write(priv, LVDS_CTRL, HS_DISABLE);
-
-	val = media_blk_read(priv,LVDS_CTRL);
-	bg_en = !!(val & BG_EN);
-	val |= BG_EN;
-	media_blk_write(priv, LVDS_CTRL, val);
-
-	if (!bg_en){
-		usleep_range(15, 20);
-	}
-		
-	val = media_blk_read(priv, LVDS_CTRL);
-	val |= CH_EN;
-	val |= BIT(3);
-	media_blk_write(priv, LVDS_CTRL, val);
-
-#ifdef CONFIG_TARGET_UCM_IMX8M_PLUS
-	media_blk_write(priv, LDB_CTRL, LDB_CH0_MODE_EN_TO_DI0 | CH0_DATA_WIDTH_24BIT);
-#else
-	media_blk_write(priv, LDB_CTRL, LDB_CH0_MODE_EN_TO_DI0 | CH0_DATA_WIDTH_24BIT | CH0_BIT_MAPPING_JEIDA);
-#endif
- 
-	usleep_range(5, 10);
-	
-	return 0;
-
-}
-
-int imx8mp_ldb_read_timing(struct udevice *dev, struct display_timing *timing)
-{
-	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
-
-	if (dev->plat_ == NULL)
-		return -EINVAL;
-
-	if (timing) {
-		memcpy(timing, &priv->timings, sizeof(struct display_timing));
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int imx8mp_ldb_probe(struct udevice *dev)
-{
-	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
-	int ret;
-
-	debug("%s\n", __func__);
-
-	if (dev->plat_ == NULL) {
-		priv->regmap = syscon_regmap_lookup_by_phandle(dev, "gpr");
-		if (IS_ERR(priv->regmap)) {
-			debug("fail to get fsl,imx8mp-mediamix-blk-ctl regmap\n");
-			return PTR_ERR(priv->regmap);
-		}
-
-		/* Require to add alias in DTB */
-		priv->ldb_id = dev_seq(dev);
-
-		debug("ldb_id %u\n", priv->ldb_id);
-	}else{
-		
-		priv->conn_dev = video_link_get_next_device(dev);
-		if (!priv->conn_dev) {
-			debug("can't find next device in video link\n");
-		}
-
-		ret = video_link_get_display_timings(&priv->timings);
-		if (ret) {
-			debug("decode display timing error %d\n", ret);
-			return ret;
-		}
-		
-		if(priv->conn_dev && device_get_uclass_id(priv->conn_dev) == UCLASS_PANEL){
-			ret = panel_enable_backlight(priv->conn_dev);
-			if (ret) {
-					dev_err(dev, "fail to enable panel backlight\n");
-					return ret;
-			}
-			ret = panel_set_backlight(priv->conn_dev, 80);
-				if (ret) {
-					dev_err(dev, "fail to set panel backlight\n");
-					return ret;
-			}
-		}
-
-		if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
-			if (priv->conn_dev &&
-				device_get_uclass_id(priv->conn_dev) == UCLASS_VIDEO_BRIDGE) {
-
-				ret = video_bridge_attach(priv->conn_dev);
-				if (ret) {
-					dev_err(dev, "fail to attach bridge\n");
-					return ret;
-				}
-				ret = video_bridge_set_active(priv->conn_dev, true);
-				if (ret) {
-					dev_err(dev, "fail to active bridge\n");
-					return ret;
-				}
-			}
-		}
-	}
-    debug("imx8mp_ldb_probe\n");
-
-	return 0;
-
-}
-
-static int imx8mp_ldb_bind(struct udevice *dev)
-{
-	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
-	ofnode lvds_ch_node;
-	int ret = 0;
-
-	debug("%s\n", __func__);
-	lvds_ch_node = ofnode_find_subnode(dev_ofnode(dev), "lvds-channel@0");
-	if (ofnode_valid(lvds_ch_node)) {
-		ret = device_bind(dev, dev->driver, "lvds-channel@0", (void *)1,
-			lvds_ch_node, NULL);
-		if (ret)
-			debug("Error binding driver '%s': %d\n", dev->driver->name,
-				ret);
-	}
-
-	return ret;
-}
-
-
-int imx8mp_ldb_enable(struct udevice *dev, int panel_bpp,
-		      const struct display_timing *timing)
-{
-	struct imx8mp_ldb_priv *priv = dev_get_priv(dev);
-	int ret;
-	debug("%s\n", __func__);
-
-	if (dev->plat_ == NULL) {
-
-		imx8mp_lvds_phy_power_on(dev);
-	} else {
-		display_enable(dev->parent, panel_bpp, &priv->timings);
-
-		if (IS_ENABLED(CONFIG_VIDEO_BRIDGE)) {
-			if (priv->conn_dev &&
-				device_get_uclass_id(priv->conn_dev) == UCLASS_VIDEO_BRIDGE) {
-				ret = video_bridge_set_backlight(priv->conn_dev, 80);
-				if (ret) {
-					dev_err(dev, "fail to set backlight\n");
-					return ret;
-				}
-			}
-		}
-	}
-
-	return 0;
-
-}
-
-struct dm_display_ops imx8mp_ldb_ops = {
-	.read_timing = imx8mp_ldb_read_timing,
-	.enable = imx8mp_ldb_enable,
-};
-
-static const struct udevice_id imx8mp_ldb_ids[] = {
-	{ .compatible = "fsl,imx8mp-ldb" },
-	{ }
-};
-
-U_BOOT_DRIVER(imx8mp_ldb) = {
-	.name				= "imx8mp_ldb",
-	.id				= UCLASS_DISPLAY,
-	.of_match			= imx8mp_ldb_ids,
-	.bind				= imx8mp_ldb_bind,
-	.probe				= imx8mp_ldb_probe,
-	.ops				= &imx8mp_ldb_ops,
-	.priv_auto		= sizeof(struct imx8mp_ldb_priv),
-};
diff --git a/drivers/video/nxp/imx/imx_lcdifv3.c b/drivers/video/nxp/imx/imx_lcdifv3.c
index bccee3fbb7..66e6ad6a86 100644
--- a/drivers/video/nxp/imx/imx_lcdifv3.c
+++ b/drivers/video/nxp/imx/imx_lcdifv3.c
@@ -4,7 +4,6 @@
  */
 
 #include <common.h>
-#include <clk.h>
 #include <malloc.h>
 #include <video.h>
 #include <video_fb.h>
@@ -33,14 +32,6 @@
 #define	PS2KHZ(ps)	(1000000000UL / (ps))
 #define HZ2PS(hz)	(1000000000UL / ((hz) / 1000))
 
-struct lcdifv3_soc_pdata {
-	bool hsync_invert;
-	bool vsync_invert;
-	bool de_invert;
-	bool hdmimix;
-	bool hvsync_high;	/* mipi needs it high */
-};
-
 struct lcdifv3_priv {
 	fdt_addr_t reg_base;
 	struct udevice *disp_dev;
@@ -49,9 +40,6 @@ struct lcdifv3_priv {
 	u32 thres_low_div;
 	u32 thres_high_mul;
 	u32 thres_high_div;
-
-	struct clk lcdif_pix;
-	struct clk *mix_clks;
 };
 
 static int lcdifv3_set_pix_fmt(struct lcdifv3_priv *priv, unsigned int format)
@@ -72,7 +60,7 @@ static int lcdifv3_set_pix_fmt(struct lcdifv3_priv *priv, unsigned int format)
 		ctrldescl0_5 |= CTRLDESCL0_5_BPP(BPP32_ARGB8888);
 		break;
 	default:
-		debug("unsupported pixel format: %u\n", format);
+		printf("unsupported pixel format: %u\n", format);
 		return -EINVAL;
 	}
 
@@ -111,8 +99,15 @@ static void lcdifv3_set_mode(struct lcdifv3_priv *priv,
 	writel(ctrldescl0_1, (ulong)(priv->reg_base + LCDIFV3_CTRLDESCL0_1));
 
 	/* Polarities */
-	writel(CTRL_INV_HS, (ulong)(priv->reg_base + LCDIFV3_CTRL_CLR));
-	writel(CTRL_INV_VS, (ulong)(priv->reg_base + LCDIFV3_CTRL_CLR));
+	if (mode->sync & FB_SYNC_VERT_HIGH_ACT)
+		writel(CTRL_INV_VS, (ulong)(priv->reg_base + LCDIFV3_CTRL_CLR));
+	else
+		writel(CTRL_INV_VS, (ulong)(priv->reg_base + LCDIFV3_CTRL_SET));
+
+	if (mode->sync & FB_SYNC_HOR_HIGH_ACT)
+		writel(CTRL_INV_HS, (ulong)(priv->reg_base + LCDIFV3_CTRL_CLR));
+	else
+		writel(CTRL_INV_HS, (ulong)(priv->reg_base + LCDIFV3_CTRL_SET));
 
 	/* SEC MIPI DSI specific */
 	writel(CTRL_INV_PXCK, (ulong)(priv->reg_base + LCDIFV3_CTRL_CLR));
@@ -211,13 +206,6 @@ static void lcdifv3_init(struct udevice *dev,
 	struct lcdifv3_priv *priv = dev_get_priv(dev);
 	int ret;
 
-	debug("%s %d dev/priv %p/%p\n",__func__,__LINE__,dev,priv);
-
-	if (priv==NULL)
-		return;
-
-	debug("%s %d %p\n",__func__,__LINE__,priv);
-
 	/* Kick in the LCDIF clock */
 	mxs_set_lcdclk(priv->reg_base, PS2KHZ(mode->pixclock));
 
@@ -232,7 +220,7 @@ static void lcdifv3_init(struct udevice *dev,
 
 	ret = lcdifv3_set_pix_fmt(priv, format);
 	if (ret) {
-		debug("Fail to init lcdifv3, wrong format %u\n", format);
+		printf("Fail to init lcdifv3, wrong format %u\n", format);
 		return;
 	}
 
@@ -271,10 +259,9 @@ static int lcdifv3_of_get_timings(struct udevice *dev,
 	priv->disp_dev = video_link_get_next_device(dev);
 	if (!priv->disp_dev ||
 		(device_get_uclass_id(priv->disp_dev) != UCLASS_VIDEO_BRIDGE
-		&& device_get_uclass_id(priv->disp_dev) != UCLASS_DISPLAY
-		&& device_get_uclass_id(priv->disp_dev) != UCLASS_PANEL)) {
+		&& device_get_uclass_id(priv->disp_dev) != UCLASS_DISPLAY)) {
 
-		debug("fail to find output device\n");
+		printf("fail to find output device\n");
 		return -ENODEV;
 	}
 
@@ -282,7 +269,7 @@ static int lcdifv3_of_get_timings(struct udevice *dev,
 
 	ret = video_link_get_display_timings(timings);
 	if (ret) {
-		debug("fail to get display timings\n");
+		printf("fail to get display timings\n");
 		return ret;
 	}
 
@@ -336,90 +323,6 @@ static void lcdifv3_of_parse_thres(struct udevice *dev)
 	}
 }
 
-
-u32 pll_rates[] = {
-	 361267200U,
-	 364000000U,
-	 384000000U,
-	 393216000U,
-	 452900000U,
-	 453000000U,
-	 497755966U,
-	 519750000U,
-	 594000000U,
-	 650000000U,
-	1039500000U,
-};
-
-static u32 get_pixclock(struct clk *pll, unsigned long pixclock, int ldb)
-{
-	unsigned long rate;
-	unsigned long best = 0, best_n = 1, best_diff = ~0;
-	unsigned long cur, cur_n, cur_diff;
-	int i;
-	int ret;
-
-
-	for (i = 0; i < ARRAY_SIZE(pll_rates); i++) {
-		rate = pll_rates[i];
-		if (!ldb)
-			cur_n = (rate + (pixclock >> 1)) / pixclock;
-		else
-			cur_n = 7;
-		cur = rate / cur_n;
-		if (cur >= pixclock)
-			cur_diff = cur - pixclock;
-		else
-			cur_diff = pixclock - cur;
-		if (best_diff > cur_diff) {
-			best_diff = cur_diff;
-			best = cur;
-			best_n = cur_n;
-		}
-		if (!cur_diff)
-			break;
-	}
-	cur = best * best_n;
-	debug("%s: %ld = %ld * %ld\n", __func__, cur, best, best_n);
-	ret = clk_set_rate(pll, cur);
-	if (ret < 0) {
-		debug("clk_set_rate %ld failed(%d)\n", cur, ret);
-		cur = clk_get_rate(pll);
-		debug("rate is %ld\n", cur);
-	}
-	best_n = (cur + (pixclock >> 1)) / pixclock;
-	pixclock = cur / best_n;
-	debug("%s: pixclock = %ld\n", __func__, pixclock);
-	return pixclock;
-}
-const char* const mix_clocks[] = {
-	"mix_apb",
-	"mix_axi",
-	"xtl_24m",
-	"mix_pix",
-	"lcdif_apb",
-	"lcdif_axi",
-	"lcdif_pdi",
-	"lcdif_pix",
-	"lcdif_spu",
-	"noc_hdmi",
-};
-
-static int hdmimix_lcdif3_setup(struct lcdifv3_priv *priv, struct udevice *dev)
-{
-	int ret;
-
-	debug("%s:\n", __func__);
-	device_reset(dev);
-	/* enable lpcg of hdmimix lcdif and nor */
-	ret = devm_clk_get_enable_bulk(dev, mix_clocks, ARRAY_SIZE(mix_clocks), 0, &priv->mix_clks);
-	if (ret) {
-		debug("%s: ret=%d\n", __func__, ret);
-		return ret;
-	}
-	return 0;
-}
-
 static int lcdifv3_video_probe(struct udevice *dev)
 {
 	struct video_uc_plat *plat = dev_get_uclass_plat(dev);
@@ -432,8 +335,6 @@ static int lcdifv3_video_probe(struct udevice *dev)
 	u32 fb_start, fb_end;
 	int ret;
 
-	struct lcdifv3_soc_pdata *pdata = (struct lcdifv3_soc_pdata *)dev_get_driver_data(dev);
-
 	debug("%s() plat: base 0x%lx, size 0x%x\n",
 	       __func__, plat->base, plat->size);
 
@@ -447,48 +348,10 @@ static int lcdifv3_video_probe(struct udevice *dev)
 	if (ret)
 		return ret;
 
-#if CONFIG_IS_ENABLED(CLK)
-{
-	struct clk* video_pll;
-	struct clk* clk_ldb;
-	u32 pixclock;
-	clk_ldb = devm_clk_get_optional(dev, "ldb");
-	if (IS_ERR(clk_ldb))
-		return PTR_ERR(clk_ldb);
-
-	video_pll = devm_clk_get_optional(dev, "video_pll");
-	if (IS_ERR(video_pll))
-		return PTR_ERR(video_pll);
-
-	if (video_pll) {
-		pixclock = get_pixclock(video_pll, timings.pixelclock.typ, clk_ldb ? 1 : 0);
-	} else {
-		pixclock = timings.pixelclock.typ;
-	}
-	ret = clk_get_by_name(dev, "pix", &priv->lcdif_pix);
-	if (ret) {
-		debug("Failed to get pix clk\n");
-		return ret;
-	}
-
-	if (clk_ldb) {
-		ret = clk_set_rate(video_pll, pixclock * 7);
-		if (ret < 0) {
-			debug("Failed to set pll rate(%d) %d\n", pixclock, ret);
-			return ret;
-		}
-	}
-
-	ret = clk_set_rate(&priv->lcdif_pix, pixclock);
-	if (ret < 0) {
-		debug("Failed to set pix clk rate(%d) %d\n", pixclock, ret);
-		return ret;
-	}
-}
-#endif
 	lcdifv3_of_parse_thres(dev);
 
 	if (priv->disp_dev) {
+#if IS_ENABLED(CONFIG_VIDEO_BRIDGE)
 		if (device_get_uclass_id(priv->disp_dev) == UCLASS_VIDEO_BRIDGE) {
 			ret = video_bridge_attach(priv->disp_dev);
 			if (ret) {
@@ -496,36 +359,19 @@ static int lcdifv3_video_probe(struct udevice *dev)
 				return ret;
 			}
 
-			ret = video_bridge_set_backlight(priv->disp_dev, 80);
+			ret = video_bridge_check_timing(priv->disp_dev, &timings);
 			if (ret) {
-				dev_err(dev, "fail to set backlight\n");
+				dev_err(dev, "fail to check timing\n");
 				return ret;
 			}
-		} else {
-			ret = display_enable(priv->disp_dev, NULL, NULL);
+
+			ret = video_bridge_set_backlight(priv->disp_dev, 80);
 			if (ret) {
+				dev_err(dev, "fail to set backlight\n");
 				return ret;
 			}
 		}
-	}
-
-	if (pdata->hvsync_high) {
-		/* mipi needs high */
-		timings.flags |= (DISPLAY_FLAGS_HSYNC_HIGH | DISPLAY_FLAGS_VSYNC_HIGH);
-		timings.flags &= ~(DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_VSYNC_LOW);
-	}
-	if (pdata->hsync_invert)
-		timings.flags ^= (DISPLAY_FLAGS_HSYNC_LOW | DISPLAY_FLAGS_HSYNC_HIGH);
-	if (pdata->vsync_invert)
-		timings.flags ^= (DISPLAY_FLAGS_VSYNC_LOW | DISPLAY_FLAGS_VSYNC_HIGH);
-	if (pdata->de_invert)
-		timings.flags ^= (DISPLAY_FLAGS_DE_LOW | DISPLAY_FLAGS_DE_HIGH);
-	if (pdata->hdmimix) {
-		ret = hdmimix_lcdif3_setup(priv, dev);
-		if (ret < 0) {
-			debug("hdmimix lcdif3 setup failed\n");
-			return ret;
-		}
+#endif
 	}
 
 	mode.xres = timings.hactive.typ;
@@ -537,6 +383,13 @@ static int lcdifv3_video_probe(struct udevice *dev)
 	mode.hsync_len = timings.hsync_len.typ;
 	mode.vsync_len = timings.vsync_len.typ;
 	mode.pixclock = HZ2PS(timings.pixelclock.typ);
+	mode.sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT;
+
+	if (timings.flags & DISPLAY_FLAGS_HSYNC_LOW )
+		mode.sync &= ~FB_SYNC_HOR_HIGH_ACT;
+
+	if (timings.flags & DISPLAY_FLAGS_VSYNC_LOW )
+		mode.sync &= ~FB_SYNC_VERT_HIGH_ACT;
 
 	lcdifv3_init(dev, &mode, GDF_32BIT_X888RGB);
 
@@ -580,32 +433,9 @@ static int lcdifv3_video_remove(struct udevice *dev)
 	return 0;
 }
 
-static const struct lcdifv3_soc_pdata imx8mp_lcdif1_pdata = {
-	.hsync_invert = false,
-	.vsync_invert = false,
-	.de_invert    = false,
-	.hdmimix     = false,
-	.hvsync_high = true,
-};
-
-static const struct lcdifv3_soc_pdata imx8mp_lcdif2_pdata = {
-	.hsync_invert = false,
-	.vsync_invert = false,
-	.de_invert    = true,
-	.hdmimix      = false,
-};
-
-static const struct lcdifv3_soc_pdata imx8mp_lcdif3_pdata = {
-	.hsync_invert = false,
-	.vsync_invert = false,
-	.de_invert    = false,
-	.hdmimix     = true,
-};
-
 static const struct udevice_id lcdifv3_video_ids[] = {
-	{ .compatible = "fsl,imx8mp-lcdif1", .data = (ulong)&imx8mp_lcdif1_pdata,},
-	{ .compatible = "fsl,imx8mp-lcdif2", .data = (ulong)&imx8mp_lcdif2_pdata,},
-	{ .compatible = "fsl,imx8mp-lcdif3", .data = (ulong)&imx8mp_lcdif3_pdata,},
+	{ .compatible = "fsl,imx8mp-lcdif1" },
+	{ .compatible = "fsl,imx93-lcdif" },
 	{ /* sentinel */ }
 };
 
diff --git a/drivers/video/nxp/imx/videomodes.h b/drivers/video/nxp/imx/videomodes.h
deleted file mode 100644
index aefe4ef94a..0000000000
--- a/drivers/video/nxp/imx/videomodes.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * (C) Copyright 2004
- * Pierre Aubert, Staubli Faverges , <p.aubert@staubli.com>
- */
-
-#include <edid.h>
-
-#ifndef CONFIG_SYS_DEFAULT_VIDEO_MODE
-#define CONFIG_SYS_DEFAULT_VIDEO_MODE	0x301
-#endif
-
-/* Some mode definitions */
-#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
-#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
-#define FB_SYNC_EXT		4	/* external sync		*/
-#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active	*/
-#define FB_SYNC_BROADCAST	16	/* broadcast video timings	*/
-					/* vtotal = 144d/288n/576i => PAL  */
-					/* vtotal = 121d/242n/484i => NTSC */
-#define FB_SYNC_ON_GREEN	32	/* sync on green */
-#define FB_VMODE_NONINTERLACED	0	/* non interlaced */
-#define FB_VMODE_INTERLACED	1	/* interlaced	*/
-#define FB_VMODE_DOUBLE		2	/* double scan */
-#define FB_VMODE_MASK		255
-
-#define FB_VMODE_YWRAP		256	/* ywrap instead of panning	*/
-#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
-#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
-
-
-/******************************************************************
- * Resolution Struct
- ******************************************************************/
-struct ctfb_res_modes {
-	int xres;		/* visible resolution		*/
-	int yres;
-	int refresh;		/* vertical refresh rate in hz  */
-	/* Timing: All values in pixclocks, except pixclock (of course) */
-	int pixclock;		/* pixel clock in ps (pico seconds) */
-	int pixclock_khz;	/* pixel clock in kHz           */
-	int left_margin;	/* time from sync to picture	*/
-	int right_margin;	/* time from picture to sync	*/
-	int upper_margin;	/* time from sync to picture	*/
-	int lower_margin;
-	int hsync_len;		/* length of horizontal sync	*/
-	int vsync_len;		/* length of vertical sync	*/
-	int sync;		/* see FB_SYNC_*		*/
-	int vmode;		/* see FB_VMODE_*		*/
-};
-
-/******************************************************************
- * Vesa Mode Struct
- ******************************************************************/
-struct ctfb_vesa_modes {
-	int vesanr;		/* Vesa number as in LILO (VESA Nr + 0x200} */
-	int resindex;		/* index to resolution struct */
-	int bits_per_pixel;	/* bpp */
-};
-
-#define RES_MODE_640x480	0
-#define RES_MODE_800x600	1
-#define RES_MODE_1024x768	2
-#define RES_MODE_960_720	3
-#define RES_MODE_1152x864	4
-#define RES_MODE_1280x1024	5
-#define RES_MODE_1280x720	6
-#define RES_MODE_1360x768	7
-#define RES_MODE_1920x1080	8
-#define RES_MODE_1920x1200	9
-#define RES_MODES_COUNT		10
-
-#define VESA_MODES_COUNT 19
-
-extern const struct ctfb_vesa_modes vesa_modes[];
-extern const struct ctfb_res_modes res_mode_init[];
-
-int video_get_params (struct ctfb_res_modes *pPar, char *penv);
-
-int video_get_video_mode(unsigned int *xres, unsigned int *yres,
-	unsigned int *depth, unsigned int *freq, const char **options);
-
-void video_get_ctfb_res_modes(int default_mode, unsigned int default_depth,
-			      const struct ctfb_res_modes **mode_ret,
-			      unsigned int *depth_ret,
-			      const char **options);
-
-void video_get_option_string(const char *options, const char *name,
-			     char *dest, int dest_len, const char *def);
-
-int video_get_option_int(const char *options, const char *name, int def);
-
-int video_edid_dtd_to_ctfb_res_modes(struct edid_detailed_timing *t,
-				     struct ctfb_res_modes *mode);
-/**
- * video_ctfb_mode_to_display_timing() - Convert a ctfb(Cathode Tube Frame
- *					 Buffer)_res_modes struct to a
- *					 display_timing struct.
- *
- * @mode:	Input ctfb_res_modes structure pointer to be converted
- *		from
- * @timing:	Output display_timing structure pointer to be converted to
- */
-void video_ctfb_mode_to_display_timing(const struct ctfb_res_modes *mode,
-				       struct display_timing *timing);
-- 
2.17.1

